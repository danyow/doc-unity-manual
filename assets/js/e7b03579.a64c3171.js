"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1596],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(a),h=o,d=m["".concat(s,".").concat(h)]||m[h]||u[h]||r;return a?n.createElement(d,i(i({ref:t},p),{},{components:a})):n.createElement(d,i({ref:t},p))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},78628:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var n=a(87462),o=a(63366),r=(a(67294),a(3905)),i=["components"],l={id:"performance-garbage-collection-best-practices",title:"Garbage collection best practices",slug:"/performance-garbage-collector/performance-garbage-collection-best-practices"},s="Garbage collection best practices",c={unversionedId:"unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-garbage-collection-best-practices",id:"unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-garbage-collection-best-practices",title:"Garbage collection best practices",description:"Garbage collection is automatic, but the process requires a significant amount of CPU time.",source:"@site/docs/unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-garbage-collection-best-practices.md",sourceDirName:"unity-overview/analysis/performance-memory-overview/performance-garbage-collector",slug:"/performance-garbage-collector/performance-garbage-collection-best-practices",permalink:"/doc-unity-manual/docs/performance-garbage-collector/performance-garbage-collection-best-practices",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-garbage-collection-best-practices.md",tags:[],version:"current",frontMatter:{id:"performance-garbage-collection-best-practices",title:"Garbage collection best practices",slug:"/performance-garbage-collector/performance-garbage-collection-best-practices"},sidebar:"tutorialSidebar",previous:{title:"Disabling garbage collection",permalink:"/doc-unity-manual/docs/performance-garbage-collector/performance-disabling-garbage-collection"},next:{title:"Incremental garbage collection",permalink:"/doc-unity-manual/docs/performance-garbage-collector/performance-incremental-garbage-collection"}},p={},u=[{value:"\u4e34\u65f6\u5206\u914d",id:"\u4e34\u65f6\u5206\u914d",level:2},{value:"Reusable object pools",id:"reusable-object-pools",level:2},{value:"Repeated string concatenation",id:"repeated-string-concatenation",level:2},{value:"Method returning an array value",id:"method-returning-an-array-value",level:2},{value:"Collection and array reuse",id:"collection-and-array-reuse",level:2},{value:"\u95ed\u5305\u548c\u533f\u540d\u65b9\u6cd5",id:"\u95ed\u5305\u548c\u533f\u540d\u65b9\u6cd5",level:2},{value:"\u88c5\u7bb1 (Boxing)",id:"\u88c5\u7bb1-boxing",level:2},{value:"\u8bc6\u522b\u88c5\u7bb1",id:"\u8bc6\u522b\u88c5\u7bb1",level:3},{value:"Array-valued Unity APIs",id:"array-valued-unity-apis",level:2},{value:"Empty array reuse",id:"empty-array-reuse",level:2},{value:"\u66f4\u591a\u8d44\u6e90",id:"\u66f4\u591a\u8d44\u6e90",level:2}],m={toc:u};function h(e){var t=e.components,a=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"garbage-collection-best-practices"},"Garbage collection best practices"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/performance-garbage-collector"},"Garbage collection")," is automatic, but the process requires a significant amount of CPU time."),(0,r.kt)("p",null,"C#\u2019s automatic memory management reduces the risk of memory leaks and other programming errors, in comparison to other programming languages like C++, where you must manually track and free all the memory you allocate."),(0,r.kt)("p",null,"Automatic memory management allows you to write code quickly and easily, and with few errors. However, this convenience might have performance implications. To optimize your code for performance, you must avoid situations where your application triggers the ",(0,r.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/performance-garbage-collector"},"garbage collector")," a lot. This section outlines some common issues and workflows that affect when your application triggers the garbage collector."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#%E4%B8%B4%E6%97%B6%E5%88%86%E9%85%8D"},"Temporary allocations")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#reusable-object-pools"},"Reusable object pools")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#repeated-string-concatenation"},"Repeated string concatenation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#method-returning-an-array-value"},"Method returning an array value")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#collection-and-array-reuse"},"Collection and array reuse")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#%E9%97%AD%E5%8C%85%E5%92%8C%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"},"Closures and anonymous methods")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#%E8%A3%85%E7%AE%B1-boxing"},"Boxing")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#array-valued-unity-apis"},"Array-valued Unity APIs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#empty-array-reuse"},"Empty array reuse"))),(0,r.kt)("h2",{id:"\u4e34\u65f6\u5206\u914d"},"\u4e34\u65f6\u5206\u914d"),(0,r.kt)("p",null,"It\u2019s common for an application to allocate temporary data to the ",(0,r.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/performance-memory-overview/performance-managed-memory#managed-heap-overview"},"managed heap")," in each frame; however, this can affect the performance of the application. For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If a program allocates one kilobyte (1KB) of temporary memory each frame, and it runs at 60 frames per second, then it must allocate 60 kilobytes of temporary memory per second. Over the course of a minute, this adds up to 3.6 megabytes of memory available to the garbage collector."),(0,r.kt)("li",{parentName:"ul"},"Invoking the garbage collector once per second has a negative effect on performance. If the garbage collector only runs once per minute, it has to clean up 3.6 megabytes spread across thousands of individual allocations, which might result in significant garbage collection times."),(0,r.kt)("li",{parentName:"ul"},"Loading operations have an impact on performance. If your application generates a lot of temporary objects during a heavy asset-loading operation, and Unity references those objects until the operation completes, then the garbage collector can\u2019t release those temporary objects. This means that the managed heap needs to expand, even though Unity releases a lot of the objects that it contains a short time later.")),(0,r.kt)("p",null,"To get around this, you should try to reduce the amount of frequently managed heap allocations as possible: ideally to 0 bytes per frame, or as close to zero as you can get."),(0,r.kt)("h2",{id:"reusable-object-pools"},"Reusable object pools"),(0,r.kt)("p",null,"There are a lot of cases where you can reduce the number of times that your application creates and destroys objects, to avoid generating garbage. There are certain types of objects in games, such as projectiles, which might appear over and over again even though only a small number are ever in play at once. In cases like this, you can reuse the objects, rather than destroy old ones and replace them with new ones."),(0,r.kt)("p",null,"For example, it\u2019s not optimal to instantiate a new projectile object from a Prefab every time one is fired. Instead, you can calculate the maximum number of projectiles that could ever exist simultaneously during gameplay, and instantiate an array of objects of the correct size when the game first enters the gameplay scene. To do this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Start with all the projectile GameObjects set to being inactive."),(0,r.kt)("li",{parentName:"ul"},"When a projectile is fired, search through the array to find the first inactive projectile in the array, move it to the required position and set the GameObject to be active."),(0,r.kt)("li",{parentName:"ul"},"When the projectile is destroyed, set the GameObject to inactive again.")),(0,r.kt)("p",null,"You can use the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Pool.ObjectPool_1.html"},"ObjectPool")," class, which provides an implementation of this reusable object pool technique."),(0,r.kt)("p",null,"The code below shows a simple implementation of a stack-based object pool. You might find it useful to refer to if you\u2019re using an older version of Unity which doesn\u2019t contain the ObjectPool API, or if you\u2019d like to see an example of how a custom object pool might be implemented."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'using System.Collections.Generic;\nusing UnityEngine;\n\npublic class ExampleObjectPool : MonoBehaviour {\n\n   public GameObject PrefabToPool;\n   public int MaxPoolSize = 10;\n  \n   private Stack&lt;GameObject&gt; inactiveObjects = new Stack&lt;GameObject&gt;();\n  \n   void Start() {\n       if (PrefabToPool != null) {\n           for (int i = 0; i &lt; MaxPoolSize; ++i) {\n               var newObj = Instantiate(PrefabToPool);\n               newObj.SetActive(false);\n               inactiveObjects.Push(newObj);\n           }\n       }\n   }\n\n   public GameObject GetObjectFromPool() {\n       while (inactiveObjects.Count &gt; 0) {\n           var obj = inactiveObjects.Pop();\n          \n           if (obj != null) {\n               obj.SetActive(true);\n               return obj;\n           }\n           else {\n               Debug.LogWarning("Found a null object in the pool. Has some code outside the pool destroyed it?");\n           }\n       }\n      \n       Debug.LogError("All pooled objects are already in use or have been destroyed");\n       return null;\n   }\n  \n   public void ReturnObjectToPool(GameObject objectToDeactivate) {\n       if (objectToDeactivate != null) {\n           objectToDeactivate.SetActive(false);\n           inactiveObjects.Push(objectToDeactivate);\n       }\n   }\n}\n')),(0,r.kt)("h2",{id:"repeated-string-concatenation"},"Repeated string concatenation"),(0,r.kt)("p",null,"Strings in C# are immutable reference types. A reference type means that Unity allocates them on the managed heap and they\u2019re subject to garbage collection. Immutable means that once a string has been created, it can\u2019t be changed; any attempt to modify the string results in an entirely new string. For this reason, you should avoid creating temporary strings wherever possible."),(0,r.kt)("p",null,"The following example code adds new pieces of a string in each loop. The previous contents of the line variable become redundant, and the code allocates a whole new string to contain the original piece."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void ConcatExample(int[] intArray) {\n        string line = intArray[0].ToString();\n        \n        for (i = 1; i &lt; intArray.Length; i++) {\n            line += ", " + intArray[i].ToString();\n        }\n        \n        return line;\n    }\n}\n')),(0,r.kt)("p",null,"This is less efficient than adding new pieces to the string in place, one by one."),(0,r.kt)("p",null,"Because this string gets longer with increasing values of ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),", the amount of heap space consumed also increases, which means that hundreds of bytes of free heap space gets used up each time this method is called. If you need to concatenate a lot of strings together then you should use Mono library\u2019s ",(0,r.kt)("a",{parentName:"p",href:"http://msdn.microsoft.com/en-gb/library/system.text.stringbuilder.aspx"},(0,r.kt)("inlineCode",{parentName:"a"},"System.Text.StringBuilder"))," class."),(0,r.kt)("p",null,"However, a repeated concatenation doesn\u2019t decrease performance too much unless you call it frequently (for example, every frame update). The following example allocates new strings each time Update is called, and generates a continuous stream of objects that garbage collection must handle:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'//C# script example\nusing UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    public Text scoreBoard;\n    public int score;\n    \n    void Update() {\n        string scoreText = "Score: " + score.ToString();\n        scoreBoard.text = scoreText;\n    }\n}\n')),(0,r.kt)("p",null,"To prevent this continuous requirement for garbage collection, you can configure the code so that the text only updates when the score changes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'//C# script example\nusing UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    public Text scoreBoard;\n    public string scoreText;\n    public int score;\n    public int oldScore;\n    \n    void Update() {\n        if (score != oldScore) {\n            scoreText = "Score: " + score.ToString();\n            scoreBoard.text = scoreText;\n            oldScore = score;\n        }\n    }\n}\n')),(0,r.kt)("h2",{id:"method-returning-an-array-value"},"Method returning an array value"),(0,r.kt)("p",null,"Sometimes it might be convenient to write a method that creates a new array, fills the array with values and then returns it. However, if this method is called repeatedly, then new memory gets allocated each time."),(0,r.kt)("p",null,"The following example code shows an example of a method which creates an array every time it\u2019s called:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    float[] RandomList(int numElements) {\n        var result = new float[numElements];\n        \n        for (int i = 0; i &lt; numElements; i++) {\n            result[i] = Random.value;\n        }\n        \n        return result;\n    }\n}\n")),(0,r.kt)("p",null,"One way you can avoid allocating memory every time is to make use of the fact that an array is a reference type. You can modify an array that\u2019s passed into a method as a parameter, and the results remain after the method returns. To do this, you can configure the example code as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void RandomList(float[] arrayToFill) {\n        for (int i = 0; i &lt; arrayToFill.Length; i++) {\n            arrayToFill[i] = Random.value;\n        }\n    }\n}\n")),(0,r.kt)("p",null,"This code replaces the existing contents of the array with new values. This workflow requires the calling code to do the initial allocation of the array, but the function doesn\u2019t generate any new garbage when it\u2019s called. The array can then be re-used and re-filled with random numbers the next time this method is called without any new allocations on the managed heap."),(0,r.kt)("h2",{id:"collection-and-array-reuse"},"Collection and array reuse"),(0,r.kt)("p",null,"When you use arrays or classes from the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=net-6.0"},(0,r.kt)("inlineCode",{parentName:"a"},"System.Collection"))," namespace (for example, Lists or Dictionaries), it\u2019s efficient to reuse or pool the allocated collection or array. Collection classes expose a Clear method, which eliminates a collection\u2019s values but doesn\u2019t release the memory allocated to the collection."),(0,r.kt)("p",null,"This is useful if you want to allocate temporary \u201chelper\u201d collections for complex computations. The following code example demonstrates this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void Update() {\n\n    // Allocating a new List every Update: you should avoid doing this.\n    List&lt;float&gt; nearestNeighbors = new List&lt;float&gt;();\n\n    findDistancesToNearestNeighbors(nearestNeighbors);\n\n    nearestNeighbors.Sort();\n\n    // \u2026 use the sorted list somehow \u2026\n}\n")),(0,r.kt)("p",null,"This example code allocates the nearestNeighbors List once per frame to collect a set of data points."),(0,r.kt)("p",null,"You can hoist this List out of the method and into the containing class, so that your code doesn\u2019t need to allocate a new List each frame:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"List&lt;float&gt; m_NearestNeighbors = new List&lt;float&gt;();\n\nvoid Update() {\n\n    m_NearestNeighbors.Clear();\n\n    findDistancesToNearestNeighbors(NearestNeighbors);\n\n    m_NearestNeighbors.Sort();\n\n    // \u2026 use the sorted list somehow \u2026\n}\n")),(0,r.kt)("p",null,"This example code retains and reuses the List\u2019s memory across multiple frames. The code only allocates new memory when the List needs to expand."),(0,r.kt)("h2",{id:"\u95ed\u5305\u548c\u533f\u540d\u65b9\u6cd5"},"\u95ed\u5305\u548c\u533f\u540d\u65b9\u6cd5"),(0,r.kt)("p",null,"In general, you should avoid closures in C# whenever possible. You should minimize the use of anonymous methods and method references in performance-sensitive code, and especially in code that executes on a per-frame basis."),(0,r.kt)("p",null,"Method references in C# are reference types, so they\u2019re allocated on the heap. This means that if you pass a method reference as an argument, it\u2019s easy to create temporary allocations. This allocation happens regardless of whether the method you pass is an anonymous method or a predefined one."),(0,r.kt)("p",null,"Also, when you convert an anonymous method to a closure, the amount of memory required to pass the closure to a method increases a lot."),(0,r.kt)("p",null,"The following code sample uses a simple anonymous method to control the sorting order of the list of numbers created on the first line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"List&lt;float&gt; listOfNumbers = createListOfRandomNumbers();\n\nlistOfNumbers.Sort( (x, y) =&gt;\n\n(int)x.CompareTo((int)(y/2)) \n\n);\n")),(0,r.kt)("p",null,"To make this snippet reusable, you might substitute the constant 2 for a variable in local scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"List&lt;float&gt; listOfNumbers = createListOfRandomNumbers();\n\nint desiredDivisor = getDesiredDivisor();\n\nlistOfNumbers.Sort( (x, y) =&gt;\n\n(int)x.CompareTo((int)(y/desiredDivisor))\n\n);\n")),(0,r.kt)("p",null,"The anonymous method now needs to access the state of a variable which is outside of its scope, and so the method has become a closure. The ",(0,r.kt)("inlineCode",{parentName:"p"},"desiredDivisor")," variable must be passed into the closure so that the closure\u2019s code can use it."),(0,r.kt)("p",null,"To ensure that the correct values are passed in to the closure, C# generates an anonymous class that can retain the externally scoped variables that the closure needs. A copy of this class is instantiated when the closure is passed to the Sort method, and the copy is initialized with the value of the desiredDivisor integer."),(0,r.kt)("p",null,"Executing the closure requires instantiating a copy of its generated class, and all classes are reference types in C#. For this reason, executing the closure requires allocation of an object on the managed heap."),(0,r.kt)("h2",{id:"\u88c5\u7bb1-boxing"},"\u88c5\u7bb1 (Boxing)"),(0,r.kt)("p",null,"Boxing is one of the most common sources of unintended temporary memory allocations found in Unity projects. It happens when a value-typed variable gets automatically converted to a reference type. This most often happens when passing primitive value-typed variables (such as int and float) to object-typed methods. You should avoid boxing when writing C# code for Unity runtimes."),(0,r.kt)("p",null,"In this example, the integer in x is boxed so that it can be passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"object.Equals")," method, because the ",(0,r.kt)("inlineCode",{parentName:"p"},"Equals")," method on an object requires that an object is passed to it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int x = 1;\n\nobject y = new object();\n\ny.Equals(x);\n")),(0,r.kt)("p",null,"C# IDEs and compilers don\u2019t issue warnings about boxing, even though boxing leads to unintended memory allocations. This is because C# assumes that small temporary allocations are efficiently handled by generational garbage collectors and allocation-size-sensitive memory pools."),(0,r.kt)("p",null,"While Unity\u2019s allocator does use different memory pools for small and large allocations, Unity\u2019s ",(0,r.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/performance-garbage-collector"},"garbage collector")," isn\u2019t generational, so it can\u2019t efficiently sweep out the small, frequent temporary allocations that boxing generates."),(0,r.kt)("h3",{id:"\u8bc6\u522b\u88c5\u7bb1"},"\u8bc6\u522b\u88c5\u7bb1"),(0,r.kt)("p",null,"Boxing appears in CPU traces as calls to one of a few methods, depending on the scripting back end in use. These take one of the following forms, where ",(0,r.kt)("inlineCode",{parentName:"p"},"&lt;example class&gt;")," is the name of a class or struct, and ",(0,r.kt)("inlineCode",{parentName:"p"},"\u2026")," is a number of arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"&lt;example class&gt;::Box(\u2026)\nBox(\u2026)\n&lt;example class&gt;_Box(\u2026)\n")),(0,r.kt)("p",null,"To find boxing, you can also search the output of a decompiler or IL viewer, such as the ",(0,r.kt)("a",{parentName:"p",href:"https://www.jetbrains.com/help/resharper/Viewing_Intermediate_Language.html"},"IL viewer tool built into ReSharper")," or the ",(0,r.kt)("a",{parentName:"p",href:"https://www.jetbrains.com/decompiler/"},"dotPeek decompiler"),". The IL instruction is ",(0,r.kt)("inlineCode",{parentName:"p"},"box"),"."),(0,r.kt)("h2",{id:"array-valued-unity-apis"},"Array-valued Unity APIs"),(0,r.kt)("p",null,"A subtle cause of unintended allocation array is the repeated accessing of Unity APIs that return arrays. All Unity APIs that return arrays create a new copy of the array each time they\u2019re accessed. If your code accesses an array-valued Unity API more often than necessary, there is likely to be a detrimental impact on performance."),(0,r.kt)("p",null,"As an example, the following code unnecessarily creates four copies of the vertices array per loop iteration. The allocations happen each time the ",(0,r.kt)("inlineCode",{parentName:"p"},".vertices")," property is accessed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"for(int i = 0; i &lt; mesh.vertices.Length; i++) {\n    float x, y, z;\n\n    x = mesh.vertices[i].x;\n    y = mesh.vertices[i].y;\n    z = mesh.vertices[i].z;\n\n    // ...\n\n    DoSomething(x, y, z);   \n}\n")),(0,r.kt)("p",null,"You can refactor this code into a single array allocation, regardless of the number of loop iterations. To do this, configure your code to capture the vertices array before the loop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"var vertices = mesh.vertices;\n\nfor(int i = 0; i &lt; vertices.Length; i++) {\n\n    float x, y, z;\n\n    x = vertices[i].x;\n    y = vertices[i].y;\n    z = vertices[i].z;\n\n    // ...\n\n    DoSomething(x, y, z);   \n}\n")),(0,r.kt)("p",null,"While the CPU performance implications of accessing a property once isn\u2019t high, repeated accesses within tight loops create CPU performance hotspots. Repeated accesses expand the ",(0,r.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/performance-memory-overview/performance-managed-memory#managed-heap-overview"},"managed heap"),"."),(0,r.kt)("p",null,"This problem is common on mobile devices, because the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/Input-touches.html"},"Input.touches")," API behaves similarly to the above. It\u2019s also common for projects to contain code similar to the following, where an allocation occurs each time the ",(0,r.kt)("inlineCode",{parentName:"p"},".touches")," property is accessed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"for ( int i = 0; i &lt; Input.touches.Length; i++ ) {\n   Touch touch = Input.touches[i];\n\n    // \u2026\n}\n")),(0,r.kt)("p",null,"To improve this, you can configure your code to hoist the array allocation out of the loop condition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Touch[] touches = Input.touches;\n\nfor ( int i = 0; i &lt; touches.Length; i++ ) {\n\n   Touch touch = touches[i];\n\n   // \u2026\n}\n")),(0,r.kt)("p",null,"However, there are now versions of a lot of Unity APIs that don\u2019t cause memory allocations. You should use these when possible."),(0,r.kt)("p",null,"The following code example converts the previous example to the allocation-less Touch API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int touchCount = Input.touchCount;\n\nfor ( int i = 0; i &lt; touchCount; i++ ) {\n   Touch touch = Input.GetTouch(i);\n\n   // \u2026\n}\n")),(0,r.kt)("p",null,"Note that the property access (",(0,r.kt)("inlineCode",{parentName:"p"},"Input.touchCount"),") remains outside the loop condition, to save the CPU impact of invoking the property\u2019s get method."),(0,r.kt)("h2",{id:"empty-array-reuse"},"Empty array reuse"),(0,r.kt)("p",null,"Some development teams prefer to return empty arrays instead of null when an array-valued method needs to return an empty set. This coding pattern is common in a lot of managed languages, particularly C# and Java."),(0,r.kt)("p",null,"In general, when returning a zero-length array from a method, it\u2019s more efficient to return a pre-allocated static instance of the zero-length array than to repeatedly create empty arrays."),(0,r.kt)("h2",{id:"\u66f4\u591a\u8d44\u6e90"},"\u66f4\u591a\u8d44\u6e90"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/doc-unity-manual/docs/performance-garbage-collector"},"Garbage collector overview")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/doc-unity-manual/docs/performance-memory-overview/performance-managed-memory"},"Managed memory overview")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/doc-unity-manual/docs/performance-garbage-collector/performance-incremental-garbage-collection"},"Incremental garbage collection"))))}h.isMDXComponent=!0}}]);