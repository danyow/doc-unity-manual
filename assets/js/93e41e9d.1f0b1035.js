"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[45390],{3905:function(e,a,n){n.d(a,{Zo:function(){return h},kt:function(){return m}});var t=n(67294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=t.createContext({}),d=function(e){var a=t.useContext(c),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},h=function(e){var a=d(e.components);return t.createElement(c.Provider,{value:a},e.children)},l={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),u=d(n),m=r,p=u["".concat(c,".").concat(m)]||u[m]||l[m]||i;return n?t.createElement(p,s(s({ref:a},h),{},{components:n})):t.createElement(p,s({ref:a},h))}));function m(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var c in a)hasOwnProperty.call(a,c)&&(o[c]=a[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var d=2;d<i;d++)s[d]=n[d];return t.createElement.apply(null,s)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},18554:function(e,a,n){n.r(a),n.d(a,{assets:function(){return h},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return l}});var t=n(87462),r=n(63366),i=(n(67294),n(3905)),s=["components"],o={id:"shader-branching",title:"Branching in shaders",slug:"/shader-variants-and-keywords/shader-branching"},c="Branching in shaders",d={unversionedId:"graphics/shaders/shaders-overview/shader-variants-and-keywords/shader-branching",id:"graphics/shaders/shaders-overview/shader-variants-and-keywords/shader-branching",title:"Branching in shaders",description:"Branching is one way of introducing conditional behavior into shader code.",source:"@site/docs/graphics/shaders/shaders-overview/shader-variants-and-keywords/shader-branching.md",sourceDirName:"graphics/shaders/shaders-overview/shader-variants-and-keywords",slug:"/shader-variants-and-keywords/shader-branching",permalink:"/doc-unity-manual/docs/shader-variants-and-keywords/shader-branching",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/graphics/shaders/shaders-overview/shader-variants-and-keywords/shader-branching.md",tags:[],version:"current",frontMatter:{id:"shader-branching",title:"Branching in shaders",slug:"/shader-variants-and-keywords/shader-branching"},sidebar:"tutorialSidebar",previous:{title:"Branching, variants, and keywords",permalink:"/doc-unity-manual/docs/shader-variants-and-keywords"},next:{title:"Conditionals in shaders",permalink:"/doc-unity-manual/docs/shader-variants-and-keywords/shader-conditionals"}},h={},l=[{value:"Static branching",id:"static-branching",level:2},{value:"Advantages and disadvantages of static branching",id:"advantages-and-disadvantages-of-static-branching",level:3},{value:"How to use static branching",id:"how-to-use-static-branching",level:3},{value:"Dynamic branching",id:"dynamic-branching",level:2},{value:"Advantages and disadvantages of dynamic branching",id:"advantages-and-disadvantages-of-dynamic-branching",level:3},{value:"How to use dynamic branching",id:"how-to-use-dynamic-branching",level:3}],u={toc:l};function m(e){var a=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,t.Z)({},u,n,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"branching-in-shaders"},"Branching in shaders"),(0,i.kt)("p",null,"Branching is one way of introducing ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/shader-conditional-code.html"},"conditional behavior")," into shader code."),(0,i.kt)("p",null,"This page contains information on the following techniques:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#static-branching"},"Static branching")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dynamic-branching"},"Dynamic branching"))),(0,i.kt)("p",null,"For a general overview of conditionals in shader code and when to use which technique, see ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/shader-variants-and-keywords/shader-conditionals"},"Conditionals in shader code"),"."),(0,i.kt)("h2",{id:"static-branching"},"Static branching"),(0,i.kt)("p",null,"When a shader program includes conditionals that are evaluated at compile time, it uses static branching. The compiler excludes the code from the unused branch, so it does not appear in the compiled shader program."),(0,i.kt)("p",null,"Internally, Unity uses static branching when it creates shader variants; however, static branching on its own does not have any of the performance disadvantages of shader variants."),(0,i.kt)("h3",{id:"advantages-and-disadvantages-of-static-branching"},"Advantages and disadvantages of static branching"),(0,i.kt)("p",null,"The main advantage of static branching is that it has no negative impact on runtime performance. The main disadvantage of static branching is that you can only use it at compile time."),(0,i.kt)("p",null,"Static branching means that the compiler excludes unneeded code from the shader program. It results in small, specialized shader programs that contain only the necessary code. There is no runtime performance cost to static branching; in fact, the smaller programs are likely to result in quicker load times and lower runtime memory usage."),(0,i.kt)("p",null,"To use static branching, the conditions must be constant at compile time. This means that you can\u2019t use it to execute code for different conditions at runtime."),(0,i.kt)("h3",{id:"how-to-use-static-branching"},"How to use static branching"),(0,i.kt)("p",null,"You can use static branching in your shaders in the following ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In hand-coded shaders:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use ","[","#if, #elif, #else, and #endif","]","(",(0,i.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-pre-if"},"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-pre-if"),") preprocessor directives, or ","[","#ifdef and #ifndef","]","(",(0,i.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-pre-ifdef"},"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-pre-ifdef"),") preprocessor directives to create static branches."),(0,i.kt)("li",{parentName:"ul"},"Use an ",(0,i.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-if"},"if statement")," that evaluates a compile-time constant value. Although ",(0,i.kt)("inlineCode",{parentName:"li"},"if")," statements can also be used for dynamic branches, the compiler detects the compile-time constant value and creates a static branch instead."),(0,i.kt)("li",{parentName:"ul"},"Unity provides ",(0,i.kt)("a",{parentName:"li",href:"/doc-unity-manual/docs/sl-shader-programs/sl-builtin-macros"},"built-in macros")," for some compile-time constants that you can use with static branches.")),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Note:"),"  Static branching is available only in hand-coded shaders. You cannot create static branches in Shader Graph."))),(0,i.kt)("h2",{id:"dynamic-branching"},"Dynamic branching"),(0,i.kt)("p",null,"When a shader program includes conditionals that are evaluated at runtime, it uses dynamic branching."),(0,i.kt)("p",null,"There are two types of dynamic branching: dynamic branching based on uniform variables, and dynamic branching based on any other runtime value. Uniform-based branching is usually more efficient, because the uniform value is constant for the whole draw call."),(0,i.kt)("p",null,"You can use ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/shader-variants-and-keywords/shader-keywords"},"shader keywords")," for dynamic branching. This allows you to use C# scripts and the Material Inspector to configure runtime branching behavior for your shaders. This results is uniform-based branching; when you do this, Unity compiles the shader keywords as uniforms."),(0,i.kt)("h3",{id:"advantages-and-disadvantages-of-dynamic-branching"},"Advantages and disadvantages of dynamic branching"),(0,i.kt)("p",null,"The main advantage of dynamic branching is that it allows you to use conditionals at runtime without increasing the number of shader variants in your project. The main disadvantage of dynamic branching is that it impacts GPU performance."),(0,i.kt)("p",null,"The GPU performance impact varies by hardware, and by shader code. The reasons are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Branching based on non-uniform variables means that the GPU must either perform different operations at the same time (and therefore break parallelism), or \u201cflatten the branch\u201d and maintain parallelism by performing the operations for both branches and then discarding one result. Branching based on uniform variables means that the GPU must flatten the branch. Both of these approaches result in reduced GPU performance."),(0,i.kt)("li",{parentName:"ul"},"For any type of dynamic branching, the GPU must allocate register space for the worst case. If one branch is much more costly than the other, this means that the GPU wastes register space. This can lead to fewer invocations of the shader program in parallel, which reduces performance.")),(0,i.kt)("p",null,"In general, if your code branches on uniform values and both branches have roughly similar workloads, then the impact on GPU performance is likely to be small. However, you should always profile your application and consider the advantages and disadvantages case-by-case."),(0,i.kt)("p",null," ",(0,i.kt)("strong",{parentName:"p"},"Note:"),"  Dynamic branching can also lead to large shader programs, because the code for all conditions is compiled into the same shader program. However, the effect of these larger files on load times and memory usage is usually less significant than the impact of shader variants."),(0,i.kt)("p",null,"For information about other ways of using conditionals in shaders, and how to decide which technique is right for your use case, see ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/shader-variants-and-keywords/shader-conditionals"},"Conditionals in shaders"),"."),(0,i.kt)("h3",{id:"how-to-use-dynamic-branching"},"How to use dynamic branching"),(0,i.kt)("p",null,"You can use dynamic branching in your shaders in the following ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In hand-coded shaders:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Optional")," : Set up ",(0,i.kt)("a",{parentName:"li",href:"/doc-unity-manual/docs/shader-variants-and-keywords/shader-keywords"},"shader keywords")," for use with with dynamic branching. You can use dynamic branching without shader keywords, but this provides simple set up and per-material configuration."),(0,i.kt)("li",{parentName:"ul"},"Use an ",(0,i.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-if"},"if statement")," that evaluates the shader keywords (if used) or any other runtime state. You can use attributes to force the GPU to execute both branches, or to execute only one branch."))),(0,i.kt)("li",{parentName:"ul"},"In Shader Graph, use a ",(0,i.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/Packages/com.unity.shadergraph@latest?subfolder=/manual/Branch-Node.html"},"Branch Node"),". This always executes both branches.")))}m.isMDXComponent=!0}}]);