"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[67376],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return h}});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=i.createContext({}),o=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},u=function(e){var n=o(e.components);return i.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=o(t),h=r,g=d["".concat(s,".").concat(h)]||d[h]||p[h]||a;return t?i.createElement(g,c(c({ref:n},u),{},{components:t})):i.createElement(g,c({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,c=new Array(a);c[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,c[1]=l;for(var o=2;o<a;o++)c[o]=t[o];return i.createElement.apply(null,c)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},45878:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return o},toc:function(){return p}});var i=t(87462),r=t(63366),a=(t(67294),t(3905)),c=["components"],l={id:"NativePluginInterface",title:"Low-level native plug-in interface",slug:"/native-plugin-interface"},s="Low-level native plug-in interface",o={unversionedId:"scripting-section/plugins/native-plugin-interface/NativePluginInterface",id:"scripting-section/plugins/native-plugin-interface/NativePluginInterface",title:"Low-level native plug-in interface",description:"Native Plug-ins in Unity can receive callbacks when certain events happen. You can use this to implement low-level rendering in your plug-in so it can work with Unity\u2019s multithreaded rendering.",source:"@site/docs/scripting-section/plugins/native-plugin-interface/native-plugin-interface.md",sourceDirName:"scripting-section/plugins/native-plugin-interface",slug:"/native-plugin-interface",permalink:"/docs/native-plugin-interface",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/scripting-section/plugins/native-plugin-interface/native-plugin-interface.md",tags:[],version:"current",frontMatter:{id:"NativePluginInterface",title:"Low-level native plug-in interface",slug:"/native-plugin-interface"},sidebar:"tutorialSidebar",previous:{title:"Plug-ins",permalink:"/docs/plugins"},next:{title:"\u4f4e\u7ea7\u539f\u751f\u63d2\u4ef6\u6e32\u67d3\u6269\u5c55",permalink:"/docs/native-plugin-interface/low-level-native-plugin-rendering-extensions"}},u={},p=[{value:"\u63a5\u53e3\u6ce8\u518c\u8868",id:"\u63a5\u53e3\u6ce8\u518c\u8868",level:2},{value:"Access to the graphics device",id:"access-to-the-graphics-device",level:2},{value:"Plug-in callbacks on the rendering thread",id:"plug-in-callbacks-on-the-rendering-thread",level:2},{value:"\u4f7f\u7528 OpenGL \u56fe\u5f62 API \u7684\u63d2\u4ef6",id:"\u4f7f\u7528-opengl-\u56fe\u5f62-api-\u7684\u63d2\u4ef6",level:2}],d={toc:p};function h(e){var n=e.components,t=(0,r.Z)(e,c);return(0,a.kt)("wrapper",(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"low-level-native-plug-in-interface"},"Low-level native plug-in interface"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/plugins/native-plugins"},"Native Plug-ins")," in Unity can receive callbacks when certain events happen. You can use this to implement low-level rendering in your plug-in so it can work with Unity\u2019s multithreaded rendering."),(0,a.kt)("h2",{id:"\u63a5\u53e3\u6ce8\u518c\u8868"},"\u63a5\u53e3\u6ce8\u518c\u8868"),(0,a.kt)("p",null,"To handle main Unity events, a plug-in must export ",(0,a.kt)("inlineCode",{parentName:"p"},"UnityPluginLoad")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"UnityPluginUnload")," functions. IUnityInterfaces enables the plug-in to access these functions, which you can find in ",(0,a.kt)("inlineCode",{parentName:"p"},"IUnityInterface.h")," in the plug-in API:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'# include "IUnityInterface.h"\n# include "IUnityGraphics.h"\n// Unity \u63d2\u4ef6\u52a0\u8f7d\u4e8b\u4ef6\nextern "C" void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API\n    UnityPluginLoad(IUnityInterfaces* unityInterfaces)\n{\n    IUnityGraphics* graphics = unityInterfaces-&gt;Get&lt;IUnityGraphics&gt;();\n}\n')),(0,a.kt)("h2",{id:"access-to-the-graphics-device"},"Access to the graphics device"),(0,a.kt)("p",null,"Use the ",(0,a.kt)("inlineCode",{parentName:"p"},"IUnityGraphics")," interface, which you can find in ",(0,a.kt)("inlineCode",{parentName:"p"},"IUnityGraphics.h"),", to give a plug-in access to generic graphics device functionality. This script demonstrates how you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"IUnityGraphics")," interface to register a callback:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'#include "IUnityInterface.h"\n#include "IUnityGraphics.h"\n    \nstatic IUnityInterfaces* s_UnityInterfaces = NULL;\nstatic IUnityGraphics* s_Graphics = NULL;\nstatic UnityGfxRenderer s_RendererType = kUnityGfxRendererNull;\n    \n// Unity plugin load event\nextern "C" void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API\n    UnityPluginLoad(IUnityInterfaces* unityInterfaces)\n{\n    s_UnityInterfaces = unityInterfaces;\n    s_Graphics = unityInterfaces-&gt;Get&lt;IUnityGraphics&gt;();\n        \n    s_Graphics-&gt;RegisterDeviceEventCallback(OnGraphicsDeviceEvent);\n        \n    // Run OnGraphicsDeviceEvent(initialize) manually on plugin load\n    // to not miss the event in case the graphics device is already initialized\n    OnGraphicsDeviceEvent(kUnityGfxDeviceEventInitialize);\n}\n    \n// Unity plugin unload event\nextern "C" void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API\n    UnityPluginUnload()\n{\n    s_Graphics-&gt;UnregisterDeviceEventCallback(OnGraphicsDeviceEvent);\n}\n    \nstatic void UNITY_INTERFACE_API\n    OnGraphicsDeviceEvent(UnityGfxDeviceEventType eventType)\n{\n    switch (eventType)\n    {\n        case kUnityGfxDeviceEventInitialize:\n        {\n            s_RendererType = s_Graphics-&gt;GetRenderer();\n            //TODO: user initialization code\n            break;\n        }\n        case kUnityGfxDeviceEventShutdown:\n        {\n            s_RendererType = kUnityGfxRendererNull;\n            //TODO: user shutdown code\n            break;\n        }\n        case kUnityGfxDeviceEventBeforeReset:\n        {\n            //TODO: user Direct3D 9 code\n            break;\n        }\n        case kUnityGfxDeviceEventAfterReset:\n        {\n            //TODO: user Direct3D 9 code\n            break;\n        }\n    };\n}\n')),(0,a.kt)("h2",{id:"plug-in-callbacks-on-the-rendering-thread"},"Plug-in callbacks on the rendering thread"),(0,a.kt)("p",null,"You can use multithreading to render in Unity, if the platform and number of available CPUs allows for it."),(0,a.kt)("p",null," ",(0,a.kt)("strong",{parentName:"p"},"Note")," : When you use multithreaded rendering, the rendering API commands happen on a thread that is completely separate from the thread that runs MonoBehaviour scripts. The communication between the main thread and the render thread means that your plug-in might not start rendering immediately, depending on how much work the main thread has pushed to the render thread."),(0,a.kt)("p",null,"To render from the plug-in, call ",(0,a.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/GL.IssuePluginEvent.html"},"GL.IssuePluginEvent")," from your managed plug-in script. This causes Unity\u2019s rendering pipeline to call the native function from the render thread, as demonstrated in the code example below. For example, if you call GL.IssuePluginEvent from the Camera\u2019s OnPostRender function, the function will call a plug-in callback immediately after the camera has finished rendering."),(0,a.kt)("p",null,"Native plugin code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'// Plugin function to handle a specific rendering event\nstatic void UNITY_INTERFACE_API OnRenderEvent(int eventID)\n{\n    // User rendering code\n}\n    \n// Freely defined function to pass a callback to plugin-specific scripts\nextern "C" UnityRenderingEvent UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API\n    GetRenderEventFunc()\n{\n    return OnRenderEvent;\n}\n')),(0,a.kt)("p",null,"Managed plug-in code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'#if UNITY_IPHONE && !UNITY_EDITOR\n[DllImport ("__Internal")]\n#else\n[DllImport("RenderingPlugin")]\n#endif\nprivate static extern IntPtr GetRenderEventFunc();\n    \n// Queue a specific callback to be called on the render thread\nGL.IssuePluginEvent(GetRenderEventFunc(), 1);\n')),(0,a.kt)("p",null,"The signature for the ",(0,a.kt)("inlineCode",{parentName:"p"},"UnityRenderingEvent")," callback is provided in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Unity-Technologies/NativeRenderingPlugin/tree/master/PluginSource/source/Unity"},"IUnityGraphics.h in the Native Rendering Plugin sample"),"."),(0,a.kt)("h2",{id:"\u4f7f\u7528-opengl-\u56fe\u5f62-api-\u7684\u63d2\u4ef6"},"\u4f7f\u7528 OpenGL \u56fe\u5f62 API \u7684\u63d2\u4ef6"),(0,a.kt)("p",null,"There are two kinds of OpenGL objects:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Objects shared across OpenGL contexts")," , such as texture, buffer, renderbuffer, samplers, query, shader, and program objects."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Per-OpenGL context objects")," , such as vertex array, framebuffer, program pipeline, transform feedback, and sync objects.")),(0,a.kt)("p",null,"Unity uses multiple OpenGL contexts. When initializing and closing the Editor and the Player, Unity relies on a master context, but when rendering it uses dedicated contexts. This means you can\u2019t create per-context objects during ",(0,a.kt)("inlineCode",{parentName:"p"},"kUnityGfxDeviceEventInitialize")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"kUnityGfxDeviceEventShutdown")," events."),(0,a.kt)("hr",null),(0,a.kt)("p",null,"\u2022 2017\u201305\u201316 \u9875\u9762\u5df2\u4fee\u8ba2",(0,a.kt)("br",null)))}h.isMDXComponent=!0}}]);