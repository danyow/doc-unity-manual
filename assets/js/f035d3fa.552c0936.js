"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[26236],{3905:function(e,t,i){i.d(t,{Zo:function(){return m},kt:function(){return d}});var n=i(67294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,r=function(e,t){if(null==e)return{};var i,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var p=n.createContext({}),l=function(e){var t=n.useContext(p),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},m=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var i=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=l(i),d=r,h=c["".concat(p,".").concat(d)]||c[d]||u[d]||a;return i?n.createElement(h,o(o({ref:t},m),{},{components:i})):n.createElement(h,o({ref:t},m))}));function d(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=i.length,o=new Array(a);o[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=i[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}c.displayName="MDXCreateElement"},11826:function(e,t,i){i.r(t),i.d(t,{assets:function(){return m},contentTitle:function(){return p},default:function(){return d},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var n=i(87462),r=i(63366),a=(i(67294),i(3905)),o=["components"],s={id:"texture-mipmaps-introduction",title:"Mipmaps introduction",slug:"/texture-mipmaps/texture-mipmaps-introduction"},p="Mipmaps introduction",l={unversionedId:"graphics/textures/texture-mipmaps/texture-mipmaps-introduction",id:"graphics/textures/texture-mipmaps/texture-mipmaps-introduction",title:"Mipmaps introduction",description:"A mip or mip level is a version of a texture with a specific resolution. Mips exist in sets called mipmaps. Mipmaps contain progressively smaller and lower resolution versions of a single texture.",source:"@site/docs/graphics/textures/texture-mipmaps/texture-mipmaps-introduction.md",sourceDirName:"graphics/textures/texture-mipmaps",slug:"/texture-mipmaps/texture-mipmaps-introduction",permalink:"/doc-unity-manual/docs/texture-mipmaps/texture-mipmaps-introduction",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/graphics/textures/texture-mipmaps/texture-mipmaps-introduction.md",tags:[],version:"current",frontMatter:{id:"texture-mipmaps-introduction",title:"Mipmaps introduction",slug:"/texture-mipmaps/texture-mipmaps-introduction"},sidebar:"tutorialSidebar",previous:{title:"Streaming Controller component",permalink:"/doc-unity-manual/docs/texture-mipmaps/class-streaming-controller"},next:{title:"The Mipmap Streaming system API",permalink:"/doc-unity-manual/docs/texture-mipmaps/texture-streaming-api"}},m={},u=[{value:"How the GPU samples mip levels",id:"how-the-gpu-samples-mip-levels",level:2},{value:"Mip bias",id:"mip-bias",level:2},{value:"How Unity loads mipmaps",id:"how-unity-loads-mipmaps",level:2}],c={toc:u};function d(e){var t=e.components,i=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"mipmaps-introduction"},"Mipmaps introduction"),(0,a.kt)("p",null,"A mip or mip level is a version of a texture with a specific resolution. Mips exist in sets called mipmaps. Mipmaps contain progressively smaller and lower resolution versions of a single texture."),(0,a.kt)("p",null,"For example, a mipmap might contain 4 versions of a texture, from the original texture (Mip 0), to Mip 1, Mip 2, and Mip 3:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/mipmaps.png",alt:"Mip levels"})),(0,a.kt)("p",null,"Mip levels"),(0,a.kt)("p",null,"Mipmaps are commonly used for rendering objects in 3D scenes, where textured objects can vary in distance from the camera. A higher mip level is used for objects closer to the camera, and lower mip levels are used for more distant objects."),(0,a.kt)("p",null,"Mipmaps can speed up rendering operations and reduce rendering artifacts in situations where the GPU renders a texture at less than its full resolution. A mip is effectively a cached, downsampled version of the original texture. Instead of performing many sampling operations on the original, full resolution texture, the GPU can perform a smaller number of operations on the already downsampled version."),(0,a.kt)("p",null,"Sometimes, mipmaps aren\u2019t beneficial. Mipmaps increase the size of a texture by 33%, both on disk and in memory. They also provide no benefit when a texture is only rendered at its full resolution, such as a UI texture that isn\u2019t scaled. You can create a mipmap for a texture manually, or you can instruct Unity to generate a mipmap for you. To automatically generate a mipmap, you should make sure that your original texture\u2019s resolution is a power of two value, as shown in the example mipmap image."),(0,a.kt)("p",null,"You can enable or disable mipmaps for a texture asset in the ",(0,a.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/class-texture-importer"},"Texture Import Settings Inspector"),"."),(0,a.kt)("h2",{id:"how-the-gpu-samples-mip-levels"},"How the GPU samples mip levels"),(0,a.kt)("p",null,"When the GPU samples a texture, it determines which mip level to use based on the texture coordinates (UVs) for the current pixel, and two internal values that the GPU calculates: DDX and DDY. DDX and DDY provide information about the UVs of the pixels beside and above the current pixel, including distances and angles."),(0,a.kt)("p",null,"The GPU uses these values to determine how much of a texture\u2019s detail is visible to the camera. A greater distance and a more extreme angle between the current pixel and its neighbors means that the GPU should pick a lower resolution mip; a shorter distance and less extreme angle means that the GPU should pick a mip with a higher resolution."),(0,a.kt)("p",null,"The GPU can also blend the texture information from two mips together when using trilinear filtering. Blending mips while sampling can make the transition from one mip to another less noticeable. To blend mips, the GPU takes a specific percentage of texture information from one mip and the rest from another mip."),(0,a.kt)("h2",{id:"mip-bias"},"Mip bias"),(0,a.kt)("p",null,"A setting called mip bias can do two things during sampling, depending on your sampler settings:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The mip bias can change the threshold for the GPU selecting a lower or higher mip for a sample. The GPU selects a specific mip when using point filtering in your sampler. For example, the GPU\u2019s might decide that the texture at a set of UVs should use a sample from Mip 3. With a mip bias of \u20132, the GPU would use the higher resolution Mip 1 for the sample, instead."),(0,a.kt)("li",{parentName:"ul"},"The mip bias can tell the GPU to prefer one mip over another by an exact percentage when blending samples from different mips. The GPU blends mips when using linear or trilinear filtering in your sampler. For example, the GPU\u2019s calculations might return a value of 0.5. The 0.5 value tells the GPU to take 50% of the texture information it needs from one mip, and the remaining 50% from the next mip in the mipmap. With an added mip bias of 0.2, the 0.5 value would change to 0.7, and the GPU would take 70% of the texture information from the first mip and only 30% from the second.")),(0,a.kt)("p",null,"The GPU has a global mip bias that it applies to its mip selection by default. Textures can have their own mip bias, which Unity adds or subtracts from the global mip bias. You can also specify your own mip bias for an individual texture sampling operation in your shaders."),(0,a.kt)("p",null,"To set the mip bias for an individual texture, see ",(0,a.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/Texture-mipMapBias.html"},"Texture.mipMapBias"),". To set a mip bias for a texture sampling operation in a hand-coded shader, use HLSL functions such as ",(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias"},"tex2dbias"),". To set a mip bias for a texture sampling operation in Shader Graph, see ",(0,a.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/Packages/com.unity.shadergraph@latest/index.html?subfolder=/manual/Sample-texture-2D-Array-Node.html"},"Sample texture 2D Array node")," or ",(0,a.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/Packages/com.unity.shadergraph@latest/index.html?subfolder=/manual/Sample-texture-2D-Node.html"},"Sample texture 2D node"),"."),(0,a.kt)("h2",{id:"how-unity-loads-mipmaps"},"How Unity loads mipmaps"),(0,a.kt)("p",null,"You can control the way that Unity loads mipmaps at runtime using ",(0,a.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/texture-mipmaps/texture-streaming"},"Mipmap Streaming"),"."))}d.isMDXComponent=!0}}]);