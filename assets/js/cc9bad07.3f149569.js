"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[15559],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(h,s(s({ref:t},d),{},{components:n})):a.createElement(h,s({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},78006:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return c}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),s=["components"],o={id:"gpu-instancing-shader",title:"Creating shaders that support GPU instancing",slug:"/gpuinstancing/gpu-instancing-shader"},l=void 0,p={unversionedId:"graphics/graphics-performance-profiling/optimizing-draw-calls/gpuinstancing/gpu-instancing-shader",id:"graphics/graphics-performance-profiling/optimizing-draw-calls/gpuinstancing/gpu-instancing-shader",title:"Creating shaders that support GPU instancing",description:"Creating shaders that support GPU instancing",source:"@site/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/gpuinstancing/gpu-instancing-shader.md",sourceDirName:"graphics/graphics-performance-profiling/optimizing-draw-calls/gpuinstancing",slug:"/gpuinstancing/gpu-instancing-shader",permalink:"/doc-unity-manual/docs/gpuinstancing/gpu-instancing-shader",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/gpuinstancing/gpu-instancing-shader.md",tags:[],version:"current",frontMatter:{id:"gpu-instancing-shader",title:"Creating shaders that support GPU instancing",slug:"/gpuinstancing/gpu-instancing-shader"},sidebar:"tutorialSidebar",previous:{title:"GPU \u5b9e\u4f8b\u5316",permalink:"/doc-unity-manual/docs/gpuinstancing"},next:{title:"Scriptable Render Pipeline Batcher",permalink:"/doc-unity-manual/docs/optimizing-draw-calls/srpbatcher"}},d={},c=[{value:"Creating shaders that support GPU instancing",id:"creating-shaders-that-support-gpu-instancing",level:2},{value:"Render pipeline compatibility",id:"render-pipeline-compatibility",level:3},{value:"Shader modifications",id:"shader-modifications",level:3},{value:"Instancing_options switches",id:"instancing_options-switches",level:3},{value:"Using shader variants with GPU instancing",id:"using-shader-variants-with-gpu-instancing",level:3},{value:"Adding per-instance properties to GPU instancing shaders",id:"adding-per-instance-properties-to-gpu-instancing-shaders",level:3},{value:"Surface shader example",id:"surface-shader-example",level:4},{value:"Vertex and fragment shader example",id:"vertex-and-fragment-shader-example",level:4},{value:"Changing per-instance data at runtime example",id:"changing-per-instance-data-at-runtime-example",level:4}],u={toc:c};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"creating-shaders-that-support-gpu-instancing"},"Creating shaders that support GPU instancing"),(0,i.kt)("p",null,"This page contains information on how to add GPU instancing support to a custom Unity shader. It first explains the shader keywords, variables, and functions custom Unity shaders require to support GPU instancing. Then it includes examples of how to add per-instance data to both surface shaders and vertex/fragment shaders."),(0,i.kt)("h3",{id:"render-pipeline-compatibility"},"Render pipeline compatibility"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u529f\u80fd")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u5185\u7f6e\u6e32\u67d3\u7ba1\u7ebf")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u901a\u7528\u6e32\u67d3\u7ba1\u7ebf (URP)")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u9ad8\u6e05\u6e32\u67d3\u7ba1\u7ebf (HDRP)")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Custom Scriptable Render Pipeline (SRP)")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Custom GPU instanced shaders")),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5426"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5426"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5426")))),(0,i.kt)("h3",{id:"shader-modifications"},"Shader modifications"),(0,i.kt)("p",null,"This section contains information about shader additions that relate to GPU instancing."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"\u6dfb\u52a0"),(0,i.kt)("th",{parentName:"tr",align:null},"\u63cf\u8ff0"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"#pragma multi_compile_instancing")),(0,i.kt)("td",{parentName:"tr",align:null},"Generates instancing variants. This is required for fragment and vertex shaders. It is optional for Surface Shaders.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"#pragma instancing_options")),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies options that Unity uses for instances. For information on the option switches available, see ","[","#pragma instancing","_","options","]","(#Instancing","_","options-switches).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_VERTEX_INPUT_INSTANCE_ID")),(0,i.kt)("td",{parentName:"tr",align:null},"Defines an instance ID in the vertex shader input/output structure. To use this macro, enable the INSTANCING","_","ON shader keyword. Otherwise, Unity doesn\u2019t set up the instance ID.",(0,i.kt)("br",null),"To access the instance ID, use ",(0,i.kt)("inlineCode",{parentName:"td"},"vertexInput.instanceID")," inside an #ifdef INSTANCING","_","ON block. If you don\u2019t use this block, variants fail to compile.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_INSTANCING_BUFFER_START(bufferName)")),(0,i.kt)("td",{parentName:"tr",align:null},"Declares the start of a per-instance constant buffer named ",(0,i.kt)("inlineCode",{parentName:"td"},"bufferName"),". Use this macro with ",(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_INSTANCING_BUFFER_END")," to wrap declarations of the properties that you want to be unique to each instance. Declare properties inside the buffer using ",(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_DEFINE_INSTANCED_PROP"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_INSTANCING_BUFFER_END(bufferName)")),(0,i.kt)("td",{parentName:"tr",align:null},"Declares the end of a per-instance constant buffer named ",(0,i.kt)("inlineCode",{parentName:"td"},"bufferName"),". Use this macro with ",(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_INSTANCING_BUFFER_START")," to wrap declarations of the properties that you want to be unique to each instance. Declare properties inside the buffer using ",(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_DEFINE_INSTANCED_PROP"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_DEFINE_INSTANCED_PROP(type, propertyName)")),(0,i.kt)("td",{parentName:"tr",align:null},"Defines a per-instance shader property with the specified type and name. In the examples below, the ",(0,i.kt)("inlineCode",{parentName:"td"},"_Color")," property is unique.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_SETUP_INSTANCE_ID(v);")),(0,i.kt)("td",{parentName:"tr",align:null},"Allows shader functions to access the instance ID. For vertex shaders, this macro is required at the beginning. For fragment shaders, this addition is optional. For an example, see ",(0,i.kt)("a",{parentName:"td",href:"#vertex-and-fragment-shader-example"},"Vertex and fragment shader"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_TRANSFER_INSTANCE_ID(v, o);")),(0,i.kt)("td",{parentName:"tr",align:null},"Copies the instance ID from the input structure to the output structure in the vertex shader. Use this macro if you need to access per-instance data in the fragment shader.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UNITY_ACCESS_INSTANCED_PROP(bufferName, propertyName)")),(0,i.kt)("td",{parentName:"tr",align:null},"Accesses a per-instance shader property in an instancing constant buffer. Unity uses the instance ID to index into the instance data array. ",(0,i.kt)("inlineCode",{parentName:"td"},"bufferName")," must match the name of the constant buffer that contains the specified property. This macro compiles differently for INSTANCING","_","ON and non-instancing variants.")))),(0,i.kt)("p",null,"When you use multiple per-instance properties, you don\u2019t need to fill all of them in ",(0,i.kt)("inlineCode",{parentName:"p"},"MaterialPropertyBlock")," objects. Also, if one instance lacks a property, Unity takes the default value from the referenced material. If the material doesn\u2019t have a default value for the property, Unity sets the value to 0. Don\u2019t put non-instanced properties in the ",(0,i.kt)("inlineCode",{parentName:"p"},"MaterialPropertyBlock"),", because this disables instancing. Instead, create different materials for them."),(0,i.kt)("h3",{id:"instancing_options-switches"},"Instancing","_","options switches"),(0,i.kt)("p",null,"The ","[","#pragma instancing","_","options","]","(#pragma-instancing","_","options) directive can use the following switches:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u5f00\u5173")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u63cf\u8ff0")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"forcemaxcount:batchSize")," \u548c ",(0,i.kt)("inlineCode",{parentName:"td"},"maxcount:batchSize")),(0,i.kt)("td",{parentName:"tr",align:null},"On most platforms, Unity automatically calculates the instancing data array size. It divides the maximum constant buffer size on the target device with the size of the structure that contains all per-instance properties. Generally, you don\u2019t need to worry about the batch size. However, some platforms require a fixed array size. To specify the batch size for those platforms, use the ",(0,i.kt)("inlineCode",{parentName:"td"},"maxcount")," option. Other platforms ignore this option. If you want to force a batch size for all platforms, use ",(0,i.kt)("inlineCode",{parentName:"td"},"forcemaxcount"),". This is useful when, for example, your project uses DrawMeshInstanced to issue draw calls with 256 instanced sprites. The default value for the two options is 500.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"assumeuniformscaling")),(0,i.kt)("td",{parentName:"tr",align:null},"Instructs Unity to assume that all the instances have uniform scalings (the same scale for all X, Y, and Z axes).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"nolodfade")),(0,i.kt)("td",{parentName:"tr",align:null},"Makes Unity not apply GPU instancing to ",(0,i.kt)("a",{parentName:"td",href:"/doc-unity-manual/docs/level-of-detail"},"LOD")," fade values.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"nolightprobe")),(0,i.kt)("td",{parentName:"tr",align:null},"Prevents Unity from applying GPU instancing to ",(0,i.kt)("a",{parentName:"td",href:"/doc-unity-manual/docs/light-probes"},"Light Probe")," values and their occlusion data. Setting this option to ",(0,i.kt)("inlineCode",{parentName:"td"},"ON")," can improve performance if your project doesn\u2019t contain GameObjects that use both GPU instancing and Light Probes.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"nolightmap")),(0,i.kt)("td",{parentName:"tr",align:null},"Prevents Unity from applying GPU instancing to lightmap atlas information values. Setting this option to ",(0,i.kt)("inlineCode",{parentName:"td"},"ON")," can improve performance if your project doesn\u2019t contain GameObjects that use both GPU instancing and lightmaps.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"procedural:FunctionName")),(0,i.kt)("td",{parentName:"tr",align:null},"Generates an additional variant for use with ",(0,i.kt)("a",{parentName:"td",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Graphics.DrawMeshInstancedIndirect.html"},"Graphics.DrawMeshInstancedIndirect"),".At the beginning of the vertex shader stage, Unity calls the function specified after the colon. To set up the instance data manually, add per-instance data to this function in the same way you would normally add per-instance data to a shader. Unity also calls this function at the beginning of a fragment shader if any of the fetched instance properties are included in the fragment shader.")))),(0,i.kt)("h3",{id:"using-shader-variants-with-gpu-instancing"},"Using shader variants with GPU instancing"),(0,i.kt)("p",null,"Unity generates Surface shaders with instancing ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/shader-preprocessor-directives/sl-multiple-program-variants"},"variants")," by default, unless you specify ",(0,i.kt)("inlineCode",{parentName:"p"},"noinstancing")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"#pragma")," directive. Unity ignores uses of #pragma multi","_","compile","_","instancing in a surface shader."),(0,i.kt)("p",null,"Unity\u2019s Standard and StandardSpecular shaders have instancing support by default, but with no per-instance properties other than the transform."),(0,i.kt)("p",null,"If your scene contains no GameObjects with GPU instancing enabled, then Unity strips instancing shader variants. To override the stripping behaviour:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Open Project Settings (menu:  ",(0,i.kt)("strong",{parentName:"li"},"Edit"),"  ",">","  ",(0,i.kt)("strong",{parentName:"li"},"Project Settings")," )."),(0,i.kt)("li",{parentName:"ol"},"Go to  ",(0,i.kt)("strong",{parentName:"li"},"Graphics")," ."),(0,i.kt)("li",{parentName:"ol"},"In the  ",(0,i.kt)("strong",{parentName:"li"},"Shader Stripping"),"  section, set  ",(0,i.kt)("strong",{parentName:"li"},"Instancing Variants"),"  to  ",(0,i.kt)("strong",{parentName:"li"},"Keep All")," .")),(0,i.kt)("h3",{id:"adding-per-instance-properties-to-gpu-instancing-shaders"},"Adding per-instance properties to GPU instancing shaders"),(0,i.kt)("p",null,"By default, Unity GPU instances GameObjects with different ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/game-objects/class-transform"},"Transforms")," in each instanced draw call. To add more variation to the instances, modify the shader to add per-instance properties such as color. You can do this both in surface shaders and in vertex/fragment shaders."),(0,i.kt)("p",null,"Custom shaders don\u2019t need per-instance data, but they do require an instance ID because world matrices need one to function correctly. Surface shaders automatically set up an instance ID, but custom vertex and fragment shaders don\u2019t. To set up the ID for custom vertex and fragment shaders, use UNITY","_","SETUP","_","INSTANCE","_","ID at the beginning of the shader. For an example of how to do this, see ",(0,i.kt)("a",{parentName:"p",href:"#vertex-and-fragment-shader-example"},"Vertex and fragment shader"),"."),(0,i.kt)("p",null,"When you declare an instanced property, Unity gathers all the property values from the MaterialPropertyBlock objects set on GameObjects into a single draw call. For an example of how to use MaterialPropertyBlock objects to set per-instance data at runtime, see ",(0,i.kt)("a",{parentName:"p",href:"#changing-per-instance-data-at-runtime-example"},"Changing per-instance data at runtime"),"."),(0,i.kt)("p",null,"When adding per-instance data to multi-pass shaders, keep the following in mind:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If a multi-pass shader has more than two passes, Unity only instances the first pass. This is because Unity renders later passes together for each object, which forces material changes."),(0,i.kt)("li",{parentName:"ul"},"If you use the Forward rendering path in the Built-in Render Pipeline, Unity can\u2019t efficiently instance objects that are affected by multiple lights. Unity can only use instancing effectively for the base pass, not for additional passes. For more information about lighting passes, see documentation on ",(0,i.kt)("a",{parentName:"li",href:"/doc-unity-manual/docs/rendering-paths/render-tech-forward-rendering"},"Forward Rendering and Pass Tags"),".")),(0,i.kt)("h4",{id:"surface-shader-example"},"Surface shader example"),(0,i.kt)("p",null,"The following example demonstrates how to create an instanced Surface Shader with different color values for each instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Shader "Custom/InstancedColorSurfaceShader" \n{\n    Properties \n    {\n        _Color ("Color", Color) = (1,1,1,1)\n        _MainTex ("Albedo (RGB)", 2D) = "white" {}\n        _Glossiness ("Smoothness", Range(0,1)) = 0.5\n        _Metallic ("Metallic", Range(0,1)) = 0.0\n    }\n\n    SubShader\n    {\n        Tags { "RenderType"="Opaque" }\n        LOD 200\n        CGPROGRAM\n        // Uses the physically based standard lighting model with shadows enabled for all light types.\n        #pragma surface surf Standard fullforwardshadows\n        // Use Shader model 3.0 target\n        #pragma target 3.0\n        sampler2D _MainTex;\n        struct Input \n        {\n            float2 uv_MainTex;\n        };\n        half _Glossiness;\n        half _Metallic;\n        UNITY_INSTANCING_BUFFER_START(Props)\n           UNITY_DEFINE_INSTANCED_PROP(fixed4, _Color)\n        UNITY_INSTANCING_BUFFER_END(Props)\n        void surf (Input IN, inout SurfaceOutputStandard o) {\n            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * UNITY_ACCESS_INSTANCED_PROP(Props, _Color);\n            o.Albedo = c.rgb;\n            o.Metallic = _Metallic;\n            o.Smoothness = _Glossiness;\n            o.Alpha = c.a;\n        }\n        ENDCG\n    }\n    FallBack "Diffuse"\n}\n')),(0,i.kt)("h4",{id:"vertex-and-fragment-shader-example"},"Vertex and fragment shader example"),(0,i.kt)("p",null,"The following example demonstrates how to create an instanced vertex and fragment shader with different color values for each instance. Unlike the surface shader, when you create the vertex and fragment shader you must use UNITY","_","SETUP","_","INSTANCE","_","ID to manually set up an instance ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Shader "Custom/SimplestInstancedShader"\n{\n    Properties\n    {\n        _Color ("Color", Color) = (1, 1, 1, 1)\n    }\n\n    SubShader\n    {\n        Tags { "RenderType"="Opaque" }\n        LOD 100\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #pragma multi_compile_instancing\n            #include "UnityCG.cginc"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct v2f\n            {\n                float4 vertex : SV_POSITION;\n                UNITY_VERTEX_INPUT_INSTANCE_ID // use this to access instanced properties in the fragment shader.\n            };\n\n            UNITY_INSTANCING_BUFFER_START(Props)\n                UNITY_DEFINE_INSTANCED_PROP(float4, _Color)\n            UNITY_INSTANCING_BUFFER_END(Props)\n\n            v2f vert(appdata v)\n            {\n                v2f o;\n\n                UNITY_SETUP_INSTANCE_ID(v);\n                UNITY_TRANSFER_INSTANCE_ID(v, o);\n                o.vertex = UnityObjectToClipPos(v.vertex);\n                return o;\n            }\n\n            fixed4 frag(v2f i) : SV_Target\n            {\n                UNITY_SETUP_INSTANCE_ID(i);\n                return UNITY_ACCESS_INSTANCED_PROP(Props, _Color);\n            }\n            ENDCG\n        }\n    }\n}\n')),(0,i.kt)("h4",{id:"changing-per-instance-data-at-runtime-example"},"Changing per-instance data at runtime example"),(0,i.kt)("p",null,"The following example demonstrates how to use MaterialPropertyBlock objects to set per-instance data for a group of GameObjects at runtime. It sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"_Color")," property from the above shader examples to a random color."),(0,i.kt)("p",null," ",(0,i.kt)("strong",{parentName:"p"},"Important")," : MaterialPropertyBlocks break SRP Batcher compatibility. For more information, see ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/gpuinstancing#requirements-and-compatibility"},"GPU instancing: Requirements and Compatibility"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using UnityEngine;\n\npublic class MaterialPropertyBlockExample : MonoBehaviour\n{\n    public GameObject[] objects;\n\n    void Start()\n    {\n        MaterialPropertyBlock props = new MaterialPropertyBlock();\n        MeshRenderer renderer;\n\n        foreach (GameObject obj in objects)\n        {\n            float r = Random.Range(0.0f, 1.0f);\n            float g = Random.Range(0.0f, 1.0f);\n            float b = Random.Range(0.0f, 1.0f);\n            props.SetColor("_Color", new Color(r, g, b));\n\n            renderer = obj.GetComponent&lt;MeshRenderer&gt;();\n            renderer.SetPropertyBlock(props);\n        }\n    }\n}\n')))}m.isMDXComponent=!0}}]);