"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[91840],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=r,p=u["".concat(c,".").concat(h)]||u[h]||m[h]||i;return n?a.createElement(p,o(o({ref:t},d),{},{components:n})):a.createElement(p,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},81352:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return m}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),o=["components"],s={id:"batch-renderer-group-creating-draw-commands",title:"Creating draw commands",slug:"/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands"},c="Creating draw commands",l={unversionedId:"graphics/graphics-performance-profiling/batch-renderer-group/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands",id:"graphics/graphics-performance-profiling/batch-renderer-group/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands",title:"Creating draw commands",description:"To create draw commands, you use the BatchRendererGroup.OnPerformCulling callback. Specifically, you use the callback\u2019s BatchCullingOutput parameter. This parameter contains a NativeArray with a single element. This layout means you can directly modify the contents of the array element without Unity performing unnecessary copies. The element in the NativeArray is a BatchCullingOutputDrawCommands struct which contains the actual draw commands.",source:"@site/docs/graphics/graphics-performance-profiling/batch-renderer-group/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands.md",sourceDirName:"graphics/graphics-performance-profiling/batch-renderer-group/batch-renderer-group-creating-a-renderer",slug:"/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands",permalink:"/doc-unity-manual/docs/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/graphics/graphics-performance-profiling/batch-renderer-group/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands.md",tags:[],version:"current",frontMatter:{id:"batch-renderer-group-creating-draw-commands",title:"Creating draw commands",slug:"/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-draw-commands"},sidebar:"tutorialSidebar",previous:{title:"Creating batches",permalink:"/doc-unity-manual/docs/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-batches"},next:{title:"Initializing a BatchRendererGroup object",permalink:"/doc-unity-manual/docs/batch-renderer-group-creating-a-renderer/batch-renderer-group-initializing"}},d={},m=[],u={toc:m};function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"creating-draw-commands"},"Creating draw commands"),(0,i.kt)("p",null,"To create draw commands, you use the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Rendering.BatchRendererGroup.OnPerformCulling.html"},"BatchRendererGroup.OnPerformCulling")," callback. Specifically, you use the callback\u2019s ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Rendering.BatchCullingOutput.html"},"BatchCullingOutput")," parameter. This parameter contains a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Unity.Collections.NativeArray_1.html"},"NativeArray")," with a single element. This layout means you can directly modify the contents of the array element without Unity performing unnecessary copies. The element in the NativeArray is a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Rendering.BatchCullingOutputDrawCommands.html"},"BatchCullingOutputDrawCommands")," struct which contains the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/Rendering.BatchCullingOutputDrawCommands-drawCommands.html"},"actual draw commands"),"."),(0,i.kt)("p",null,"Your OnPerformCulling implementation can generate as many or as few draw commands as you want. A simple implementation that only uses a single mesh and material could only output a single draw command, a more complex implementation could output thousands, each with different meshes and materials."),(0,i.kt)("p",null," ",(0,i.kt)("strong",{parentName:"p"},"Note")," : To provide maximum flexibility, Unity doesn\u2019t preallocate the arrays in the BatchCullingOutputDrawCommands output struct and stores them as raw pointers so you can easily allocate them and use them from ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/Packages/com.unity.burst@latest"},"Burst")," jobs. You must allocate the arrays using ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Unity.Collections.LowLevel.Unsafe.UnsafeUtility.Malloc.html"},"UnsafeUtility.Malloc")," with the the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Unity.Collections.Allocator.TempJob.html"},"Allocator.TempJob")," allocator. The callback shouldn\u2019t release the memory. Instead, Unity releases the memory after it finishes rendering using the draw commands."),(0,i.kt)("p",null,"See the following code sample for an example of how to create draw commands. This code sample builds on the one in ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/batch-renderer-group-creating-a-renderer/batch-renderer-group-creating-batches"},"Creating batches"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"using System;\nusing Unity.Collections;\nusing Unity.Collections.LowLevel.Unsafe;\nusing Unity.Jobs;\nusing UnityEngine;\nusing UnityEngine.Rendering;\n\npublic class SimpleBRGExample : MonoBehaviour\n{\n    public Mesh mesh;\n    public Material material;\n\n    private BatchRendererGroup m_BRG;\n\n    private GraphicsBuffer m_InstanceData;\n    private BatchID m_BatchID;\n    private BatchMeshID m_MeshID;\n    private BatchMaterialID m_MaterialID;\n\n    // Some helper constants to make calculations more convenient.\n    private const int kSizeOfMatrix = sizeof(float) * 4 * 4;\n    private const int kSizeOfPackedMatrix = sizeof(float) * 4 * 3;\n    private const int kSizeOfFloat4 = sizeof(float) * 4;\n    private const int kBytesPerInstance = (kSizeOfPackedMatrix * 2) + kSizeOfFloat4;\n    private const int kExtraBytes = kSizeOfMatrix * 2;\n    private const int kNumInstances = 3;\n\n    // The PackedMatrix is a convenience type that converts matrices into\n    // the format that Unity-provided shaders expect.\n    struct PackedMatrix\n    {\n        public float c0x;\n        public float c0y;\n        public float c0z;\n        public float c1x;\n        public float c1y;\n        public float c1z;\n        public float c2x;\n        public float c2y;\n        public float c2z;\n        public float c3x;\n        public float c3y;\n        public float c3z;\n\n        public PackedMatrix(Matrix4x4 m)\n        {\n            c0x = m.m00;\n            c0y = m.m10;\n            c0z = m.m20;\n            c1x = m.m01;\n            c1y = m.m11;\n            c1z = m.m21;\n            c2x = m.m02;\n            c2y = m.m12;\n            c2z = m.m22;\n            c3x = m.m03;\n            c3y = m.m13;\n            c3z = m.m23;\n        }\n    }\n\n    private void Start()\n    {\n        m_BRG = new BatchRendererGroup(this.OnPerformCulling, IntPtr.Zero);\n        m_MeshID = m_BRG.RegisterMesh(mesh);\n        m_MaterialID = m_BRG.RegisterMaterial(material);\n\n        AllocateInstanceDateBuffer();\n        PopulateInstanceDataBuffer();\n    }\n\n    private void AllocateInstanceDateBuffer()\n    {\n        m_InstanceData = new GraphicsBuffer(GraphicsBuffer.Target.Raw,\n            BufferCountForInstances(kBytesPerInstance, kNumInstances, kExtraBytes),\n            sizeof(int));\n    }\n\n    private void PopulateInstanceDataBuffer()\n    {\n        // Place a zero matrix at the start of the instance data buffer, so loads from address 0 return zero.\n        var zero = new Matrix4x4[1] { Matrix4x4.zero };\n\n        // Create transform matrices for three example instances.\n        var matrices = new Matrix4x4[kNumInstances]\n        {\n            Matrix4x4.Translate(new Vector3(-2, 0, 0)),\n            Matrix4x4.Translate(new Vector3(0, 0, 0)),\n            Matrix4x4.Translate(new Vector3(2, 0, 0)),\n        };\n\n        // Convert the transform matrices into the packed format that the shader expects.\n        var objectToWorld = new PackedMatrix[kNumInstances]\n        {\n            new PackedMatrix(matrices[0]),\n            new PackedMatrix(matrices[1]),\n            new PackedMatrix(matrices[2]),\n        };\n\n        // Also create packed inverse matrices.\n        var worldToObject = new PackedMatrix[kNumInstances]\n        {\n            new PackedMatrix(matrices[0].inverse),\n            new PackedMatrix(matrices[1].inverse),\n            new PackedMatrix(matrices[2].inverse),\n        };\n\n        // Make all instances have unique colors.\n        var colors = new Vector4[kNumInstances]\n        {\n            new Vector4(1, 0, 0, 1),\n            new Vector4(0, 1, 0, 1),\n            new Vector4(0, 0, 1, 1),\n        };\n\n        // In this simple example, the instance data is placed into the buffer like this:\n        // Offset | Description\n        //      0 | 64 bytes of zeroes, so loads from address 0 return zeroes\n        //     64 | 32 uninitialized bytes to make working with SetData easier, otherwise unnecessary\n        //     96 | unity_ObjectToWorld, three packed float3x4 matrices\n        //    240 | unity_WorldToObject, three packed float3x4 matrices\n        //    384 | _BaseColor, three float4s\n\n        // Calculates start addresses for the different instanced properties. unity_ObjectToWorld starts\n        // at address 96 instead of 64, because the computeBufferStartIndex parameter of SetData\n        // is expressed as source array elements, so it is easier to work in multiples of sizeof(PackedMatrix).\n        uint byteAddressObjectToWorld = kSizeOfPackedMatrix * 2;\n        uint byteAddressWorldToObject = byteAddressObjectToWorld + kSizeOfPackedMatrix * kNumInstances;\n        uint byteAddressColor = byteAddressWorldToObject + kSizeOfPackedMatrix * kNumInstances;\n\n        // Upload the instance data to the GraphicsBuffer so the shader can load them.\n        m_InstanceData.SetData(zero, 0, 0, 1);\n        m_InstanceData.SetData(objectToWorld, 0, (int)(byteAddressObjectToWorld / kSizeOfPackedMatrix), objectToWorld.Length);\n        m_InstanceData.SetData(worldToObject, 0, (int)(byteAddressWorldToObject / kSizeOfPackedMatrix), worldToObject.Length);\n        m_InstanceData.SetData(colors, 0, (int)(byteAddressColor / kSizeOfFloat4), colors.Length);\n\n        // Set up metadata values to point to the instance data. Set the most significant bit 0x80000000 in each\n        // which instructs the shader that the data is an array with one value per instance, indexed by the instance index.\n        // Any metadata values that the shader uses and not set here will be zero. When such a value is used with\n        // UNITY_ACCESS_DOTS_INSTANCED_PROP (i.e. without a default), the shader interprets the\n        // 0x00000000 metadata value and loads from the start of the buffer. The start of the buffer which is\n        // is a zero matrix so this sort of load is guaranteed to return zero, which is a reasonable default value.\n        var metadata = new NativeArray&lt;MetadataValue&gt;(3, Allocator.Temp);\n        metadata[0] = new MetadataValue { NameID = Shader.PropertyToID(\"unity_ObjectToWorld\"), Value = 0x80000000 | byteAddressObjectToWorld, };\n        metadata[1] = new MetadataValue { NameID = Shader.PropertyToID(\"unity_WorldToObject\"), Value = 0x80000000 | byteAddressWorldToObject, };\n        metadata[2] = new MetadataValue { NameID = Shader.PropertyToID(\"_BaseColor\"), Value = 0x80000000 | byteAddressColor, };\n\n        // Finally, create a batch for the instances, and make the batch use the GraphicsBuffer with the\n        // instance data, and the metadata values that specify where the properties are. Note that\n        // you don't need to pass any batch size here.\n        m_BatchID = m_BRG.AddBatch(metadata, m_InstanceData.bufferHandle);\n    }\n\n    // Raw buffers are allocated in ints. This is a utility method that calculates\n    // the required number of ints for the data.\n    int BufferCountForInstances(int bytesPerInstance, int numInstances, int extraBytes = 0)\n    {\n        // Round byte counts to int multiples\n        bytesPerInstance = (bytesPerInstance + sizeof(int) - 1) / sizeof(int) * sizeof(int);\n        extraBytes = (extraBytes + sizeof(int) - 1) / sizeof(int) * sizeof(int);\n        int totalBytes = bytesPerInstance * numInstances + extraBytes;\n        return totalBytes / sizeof(int);\n    }\n\n\n    private void OnDisable()\n    {\n        m_BRG.Dispose();\n    }\n\n    public unsafe JobHandle OnPerformCulling(\n        BatchRendererGroup rendererGroup,\n        BatchCullingContext cullingContext,\n        BatchCullingOutput cullingOutput,\n        IntPtr userContext)\n    {\n        // UnsafeUtility.Malloc() requires an alignment, so use the largest integer type's alignment\n        // which is a reasonable default.\n        int alignment = UnsafeUtility.AlignOf&lt;long&gt;();\n\n        // Acquire a pointer to the BatchCullingOutputDrawCommands struct so you can easily\n        // modify it directly.\n        var drawCommands = (BatchCullingOutputDrawCommands*)cullingOutput.drawCommands.GetUnsafePtr();\n\n        // Allocate memory for the output arrays. In a more complicated implementation, you would calculate\n        // the amount of memory to allocate dynamically calculated based on what is visible.\n        // This example assumes that all of the instances are visible and thus allocates\n        // memory for each of them. The necessary allocations are as follows:\n        // - a single draw command (which draws kNumInstances instances)\n        // - a single draw range (which covers our single draw command)\n        // - kNumInstances visible instance indices.\n        // You must always allocate the arrays using Allocator.TempJob.\n        drawCommands-&gt;drawCommands = (BatchDrawCommand*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf&lt;BatchDrawCommand&gt;(), alignment, Allocator.TempJob);\n        drawCommands-&gt;drawRanges = (BatchDrawRange*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf&lt;BatchDrawRange&gt;(), alignment, Allocator.TempJob);\n        drawCommands-&gt;visibleInstances = (int*)UnsafeUtility.Malloc(kNumInstances * sizeof(int), alignment, Allocator.TempJob);\n        drawCommands-&gt;drawCommandPickingInstanceIDs = null;\n\n        drawCommands-&gt;drawCommandCount = 1;\n        drawCommands-&gt;drawRangeCount = 1;\n        drawCommands-&gt;visibleInstanceCount = kNumInstances;\n\n        // This example doens't use depth sorting, so it leaves instanceSortingPositions as null.\n        drawCommands-&gt;instanceSortingPositions = null;\n        drawCommands-&gt;instanceSortingPositionFloatCount = 0;\n\n        // Configure the single draw command to draw kNumInstances instances\n        // starting from offset 0 in the array, using the batch, material and mesh\n        // IDs registered in the Start() method. It doesn't set any special flags.\n        drawCommands-&gt;drawCommands[0].visibleOffset = 0;\n        drawCommands-&gt;drawCommands[0].visibleCount = kNumInstances;\n        drawCommands-&gt;drawCommands[0].batchID = m_BatchID;\n        drawCommands-&gt;drawCommands[0].materialID = m_MaterialID;\n        drawCommands-&gt;drawCommands[0].meshID = m_MeshID;\n        drawCommands-&gt;drawCommands[0].submeshIndex = 0;\n        drawCommands-&gt;drawCommands[0].splitVisibilityMask = 0xff;\n        drawCommands-&gt;drawCommands[0].flags = 0;\n        drawCommands-&gt;drawCommands[0].sortingPosition = 0;\n\n        // Configure the single draw range to cover the single draw command which\n        // is at offset 0.\n        drawCommands-&gt;drawRanges[0].drawCommandsBegin = 0;\n        drawCommands-&gt;drawRanges[0].drawCommandsCount = 1;\n\n        // This example doesn't care about shadows or motion vectors, so it leaves everything\n        // to the default zero values, except the renderingLayerMask which it sets to all ones\n        // so Unity renders the instances regardless of mask settings.\n        drawCommands-&gt;drawRanges[0].filterSettings = new BatchFilterSettings { renderingLayerMask = 0xffffffff, };\n\n        // Finally, write the actual visible instance indices to the array. In a more complicated\n        // implementation, this output would depend on what is visible, but this example\n        // assumes that everything is visible.\n        for (int i = 0; i &lt; kNumInstances; ++i)\n            drawCommands-&gt;visibleInstances[i] = i;\n\n        // This simple example doesn't use jobs, so it can just return an empty JobHandle.\n        // Performance sensitive applications are encouraged to use Burst jobs to implement\n        // culling and draw command output. In this case, this function would return a\n        // handle here that completes when those jobs have finished.\n        return new JobHandle();\n    }\n}\n")),(0,i.kt)("p",null,"This is the final, complete, code sample for BRG. If you attach this Component to a GameObject, set a mesh and ",(0,i.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/batch-renderer-group/dots-instancing-shaders"},"DOTS Instancing"),"-","compatible material in the Inspector, and enter Play Mode, Unity renders three instances of the mesh using the material."))}h.isMDXComponent=!0}}]);