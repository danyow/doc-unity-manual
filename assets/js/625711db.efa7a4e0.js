"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[53528],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return u}});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(a),u=n,d=m["".concat(l,".").concat(u)]||m[u]||h[u]||i;return a?r.createElement(d,s(s({ref:t},p),{},{components:a})):r.createElement(d,s({ref:t},p))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,s=new Array(i);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:n,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},35372:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return h}});var r=a(87462),n=a(63366),i=(a(67294),a(3905)),s=["components"],o={id:"optimizing-draw-calls",title:"Optimizing draw calls",slug:"/optimizing-draw-calls"},l="Optimizing draw calls",c={unversionedId:"graphics/graphics-performance-profiling/optimizing-draw-calls/optimizing-draw-calls",id:"graphics/graphics-performance-profiling/optimizing-draw-calls/optimizing-draw-calls",title:"Optimizing draw calls",description:"To draw geometry on the screen, Unity issues draw calls to the graphics API. A draw call tells the graphics API what to draw and how to draw it. Each draw call contains all the information the graphics API needs to draw on the screen, such as information about textures, shaders, and buffers. Draw calls can be resource intensive, but often the preparation for a draw call is more resource intensive than the draw call itself.",source:"@site/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/optimizing-draw-calls.md",sourceDirName:"graphics/graphics-performance-profiling/optimizing-draw-calls",slug:"/optimizing-draw-calls",permalink:"/docs/optimizing-draw-calls",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/optimizing-draw-calls.md",tags:[],version:"current",frontMatter:{id:"optimizing-draw-calls",title:"Optimizing draw calls",slug:"/optimizing-draw-calls"},sidebar:"tutorialSidebar",previous:{title:"The Frame Debugger window",permalink:"/docs/graphics-performance-profiling/frame-debugger"},next:{title:"Manually combining meshes",permalink:"/docs/optimizing-draw-calls/combining-meshes"}},p={},h=[{value:"Optimization priority",id:"optimization-priority",level:2}],m={toc:h};function u(e){var t=e.components,a=(0,n.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"optimizing-draw-calls"},"Optimizing draw calls"),(0,i.kt)("p",null,"To draw geometry on the screen, Unity issues draw calls to the graphics API. A draw call tells the graphics API what to draw and how to draw it. Each draw call contains all the information the graphics API needs to draw on the screen, such as information about textures, shaders, and buffers. Draw calls can be resource intensive, but often the preparation for a draw call is more resource intensive than the draw call itself."),(0,i.kt)("p",null,"To prepare for a draw call, the CPU sets up resources and changes internal settings on the GPU. These settings are collectively called the render state. Changes to the render state, such as switching to a different material, are the most resource-intensive operations the graphics API performs."),(0,i.kt)("p",null,"Because render-state changes are resource intensive, it is important to optimize them. The main way to optimize render-state changes is to reduce the number of them. There are two ways to do this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reduce the total number of draw calls. When you decrease the number of draw calls, you also decrease the number of render-state changes between them."),(0,i.kt)("li",{parentName:"ul"},"Organize draw calls in a way that reduces the number of changes to the render state. If the graphics API can use the same render state to perform multiple draw calls, it can group draw calls together and not need to perform as many render-state changes.")),(0,i.kt)("p",null,"Optimizing draw calls and render-state changes has a number of benefits for your application. Mainly, it improves frame times, but it also:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reduces the amount of electricity your application requires. For battery-powered devices, this reduces the rate at which batteries run out. It also reduces the amount of heat a device produces when running your application."),(0,i.kt)("li",{parentName:"ul"},"Improves maintainability of future development on your application. When you optimize draw calls and render-state changes earlier and maintain them at an optimized level, you can add more GameObjects to your scene without producing large performance overheads.")),(0,i.kt)("p",null,"There are several methods you can use in Unity to optimize and reduce draw calls and render-state changes. Some methods are more suited for certain scenes than others. The following methods are available in Unity:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/gpuinstancing"},"GPU instancing"),": Render multiple copies of the same mesh at the same time. GPU instancing is useful for drawing geometry that appears multiple times in a scene, for example, trees or bushes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/draw-call-batching"},"Draw call batching"),": Combine meshes to reduce draw calls. Unity provides the following types of built-in draw call batching:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/draw-call-batching/static-batching"},"Static batching"),": Combine meshes of ",(0,i.kt)("a",{parentName:"li",href:"/docs/game-objects/static-objects"},"static")," GameObjects in advance. Unity sends the combined data to the GPU, but renders each mesh in the combination individually. Unity can still cull the meshes individually but each draw call is less resource-intensive since the state of the data never changes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/draw-call-batching/dynamic-batching"},"Dynamic batching"),": Transforms mesh vertices on the CPU, groups vertices that share the same configuration, and renders them in one draw call. Vertices share the same configuration if they store the same number and type of attributes. For example, ",(0,i.kt)("inlineCode",{parentName:"li"},"position")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"normal"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/optimizing-draw-calls/combining-meshes"},"Manually combining meshes"),": Manually combine multiple meshes into a single mesh, using the ",(0,i.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Mesh.CombineMeshes.html"},"Mesh.CombineMeshes")," function. Unity renders the combined mesh in a single draw call instead of one draw call per mesh."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/optimizing-draw-calls/srpbatcher"},"SRP Batcher"),": If your Project uses a Scriptable Render Pipeline (SRP), use the SRP Batcher to reduce the CPU time Unity requires to prepare and dispatch draw calls for materials that use the same shader variant.")),(0,i.kt)("h2",{id:"optimization-priority"},"Optimization priority"),(0,i.kt)("p",null,"You can use multiple draw call optimization methods in the same scene but be aware that Unity prioritizes draw call optimization methods in a particular order. If you mark a GameObject to use more than one draw call optimization method, Unity uses the highest priority method. The only exception to this is the ",(0,i.kt)("a",{parentName:"p",href:"/docs/optimizing-draw-calls/srpbatcher"},"SRP Batcher"),". When you use the SRP Batcher, Unity also supports static batching for ",(0,i.kt)("a",{parentName:"p",href:"/docs/optimizing-draw-calls/srpbatcher#game-object-compatibility"},"GameObjects that are SRP Batcher compatible"),". Unity prioritizes draw call optimizations in the following order:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"SRP Batcher and static batching"),(0,i.kt)("li",{parentName:"ol"},"GPU instancing"),(0,i.kt)("li",{parentName:"ol"},"Dynamic batching")),(0,i.kt)("p",null,"If you mark a GameObject for static batching and Unity successfully batches it, Unity disables GPU instancing for that GameObject, even if the renderer uses an instancing shader. When this happens, the Inspector window displays a warning message that suggests that you disable static batching. Similarly, if Unity can use GPU instancing for a mesh, Unity disables dynamic batching for that mesh."))}u.isMDXComponent=!0}}]);