"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[31581],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return u}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),g=s(a),u=r,h=g["".concat(c,".").concat(u)]||g[u]||m[u]||o;return a?n.createElement(h,i(i({ref:t},p),{},{components:a})):n.createElement(h,i({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=g;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},70110:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return u},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return m}});var n=a(87462),r=a(63366),o=(a(67294),a(3905)),i=["components"],l={id:"performance-incremental-garbage-collection",title:"Incremental garbage collection",slug:"/performance-garbage-collector/performance-incremental-garbage-collection"},c="Incremental garbage collection",s={unversionedId:"unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-incremental-garbage-collection",id:"unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-incremental-garbage-collection",title:"Incremental garbage collection",description:"Incremental garbage collection (GC) spreads out the process of garbage collection over multiple frames. This is the default garbage collection behavior in Unity.",source:"@site/docs/unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-incremental-garbage-collection.md",sourceDirName:"unity-overview/analysis/performance-memory-overview/performance-garbage-collector",slug:"/performance-garbage-collector/performance-incremental-garbage-collection",permalink:"/doc-unity-manual/docs/performance-garbage-collector/performance-incremental-garbage-collection",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/unity-overview/analysis/performance-memory-overview/performance-garbage-collector/performance-incremental-garbage-collection.md",tags:[],version:"current",frontMatter:{id:"performance-incremental-garbage-collection",title:"Incremental garbage collection",slug:"/performance-garbage-collector/performance-incremental-garbage-collection"},sidebar:"tutorialSidebar",previous:{title:"Garbage collection best practices",permalink:"/doc-unity-manual/docs/performance-garbage-collector/performance-garbage-collection-best-practices"},next:{title:"Managed memory",permalink:"/doc-unity-manual/docs/performance-memory-overview/performance-managed-memory"}},p={},m=[{value:"Incremental garbage collection example",id:"incremental-garbage-collection-example",level:2},{value:"Disabling incremental garbage collection",id:"disabling-incremental-garbage-collection",level:2}],g={toc:m};function u(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"incremental-garbage-collection"},"Incremental garbage collection"),(0,o.kt)("p",null,"Incremental ",(0,o.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals"},"garbage collection")," (GC) spreads out the process of garbage collection over multiple frames. This is the default garbage collection behavior in Unity."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/player-settings-incremental-gc.png",alt:"To enable incremental garbage collection, open the Player Settings and enable Use incremental GC. This is enabled by default."})),(0,o.kt)("p",null,"To enable incremental garbage collection, open the Player Settings and enable  ",(0,o.kt)("strong",{parentName:"p"},"Use incremental GC")," . This is enabled by default."),(0,o.kt)("p",null,"Unity\u2019s garbage collector uses the ",(0,o.kt)("a",{parentName:"p",href:"https://www.hboehm.info/gc/"},"Boehm\u2013Demers\u2013Weiser garbage collector"),". By default, Unity uses it in incremental mode, which means that the garbage collector splits up its workload over multiple frames, instead of stopping the main CPU thread (",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent"},"stop-the-world garbage collection"),") to process all objects on the managed heap. This means that Unity makes shorter interruptions to your application\u2019s execution, instead of one long interruption to let the garbage collector process the objects on the managed heap."),(0,o.kt)("p",null,"Incremental mode doesn\u2019t make garbage collection faster overall, but because it distributes the workload over multiple frames, GC-related performance spikes are reduced. These interruptions are called  ",(0,o.kt)("strong",{parentName:"p"},"GC spikes"),"  because they appear as large spikes in the ",(0,o.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/profiler-window"},"Profiler window\u2019s")," frame time graph."),(0,o.kt)("p",null,"If you disable incremental mode ( ",(0,o.kt)("strong",{parentName:"p"},"menu: Edit ",">"," Project Settings ",">"," Player ",">"," Other Settings ",">"," Configuration ",">"," Use Incremental GC")," ), the garbage collector must examine the entire heap when it performs a collection pass. This is known as  ",(0,o.kt)("strong",{parentName:"p"},"stop-the-world"),"  garbage collection, because whenever the garbage collector runs, it stops the main CPU thread. It only resumes execution once it has processed all objects on the managed heap, which might lead to GC spikes affecting the performance of your application. The garbage collector is also non-compacting, which means that Unity doesn\u2019t redistribute any objects in memory to close the gaps between objects."),(0,o.kt)("p",null," ",(0,o.kt)("strong",{parentName:"p"},"Important:"),"  The WebGL platform doesn\u2019t support incremental garbage collection."),(0,o.kt)("p",null,"When incremental garbage collection is disabled, a GC spike happens when Unity stops running your program code to perform garbage collection. This delay might last for hundreds of milliseconds, depending on how many allocations the garbage collector needs to process, and the platform that your application is running on."),(0,o.kt)("p",null,"This is problematic for real-time applications such as games, because it\u2019s difficult for your application to sustain the consistent frame rate that smooth animation requires when the garbage collector suspends your application\u2019s execution."),(0,o.kt)("h2",{id:"incremental-garbage-collection-example"},"Incremental garbage collection example"),(0,o.kt)("p",null,"The following screenshots from the Profiler illustrate how incremental garbage collection reduces frame rate problems:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/profiler-incremental-gc.png",alt:"Profiling session with Incremental GC enabled"})),(0,o.kt)("p",null,"Profiling session with Incremental GC enabled"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/profiler-incremental-gc-disabled.png",alt:"Profiling session with Incremental GC disabled"})),(0,o.kt)("p",null,"Profiling session with Incremental GC disabled"),(0,o.kt)("p",null,"In the top profiling session,  ",(0,o.kt)("strong",{parentName:"p"},"Incremental GC"),"  is enabled. The application has a consistent 60fps frame rate, because the garbage collector distributes the garbage collection operation over several frames, and uses a small time slice of each frame (the darker green fringe just above the yellow VSync trace)."),(0,o.kt)("p",null,"The bottom profiling session has  ",(0,o.kt)("strong",{parentName:"p"},"Incremental GC"),"  disabled, and there is a clear GC spike visible. This spike interrupts the otherwise smooth 60fps frame rate, and pushes the frame in which garbage collection happens over the 16 millisecond limit required to maintain 60fps."),(0,o.kt)("p",null,"If your application uses ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/QualitySettings-vSyncCount.html"},"VSync")," or ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/Application-targetFrameRate.html"},"Application.targetFrameRate"),", Unity adjusts the time it allocates to garbage collection based on the remaining available frame time. This way, Unity can run the garbage collection in the time it would otherwise spend waiting, and can carry out garbage collection with a minimal performance impact."),(0,o.kt)("p",null," ",(0,o.kt)("strong",{parentName:"p"},"Note:"),"  If you set the  ",(0,o.kt)("strong",{parentName:"p"},"VSync Count"),"  to anything other than  ",(0,o.kt)("strong",{parentName:"p"},"Don\u2019t Sync"),"  (in your project\u2019s ",(0,o.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/comp-manager-group/class-quality-settings"},"Quality settings")," or with the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/QualitySettings-vSyncCount.html"},"Application.VSync")," property) or you enable the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/Application-targetFrameRate.html"},"Application.targetFrameRate")," property, Unity automatically uses any idle time left at the end of a given frame for incremental garbage collection."),(0,o.kt)("p",null,"To get more precise control over incremental garbage collection behavior, you can use the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Scripting.GarbageCollector.html"},"Scripting.GarbageCollector")," class. For example, if you don\u2019t want to use VSync or a target frame rate, you can calculate the amount of time available before the end of a frame yourself, and provide that time to the garbage collector to use."),(0,o.kt)("h2",{id:"disabling-incremental-garbage-collection"},"Disabling incremental garbage collection"),(0,o.kt)("p",null,"Incremental garbage collection might be problematic for your application, because when the garbage collector divides its work in this mode, it also divides the marking phase. The marking phase is the phase in which the garbage collector scans all managed objects to determine which objects are still in use, and which objects it can clean up."),(0,o.kt)("p",null,"Dividing up the marking phase works well when most of the references between objects don\u2019t change between slices of work. However, when an object reference changes, the garbage collector must scan those objects again in the next iteration. This means that too many changes can overwhelm the incremental garbage collector and create a situation where the marking phase never finishes because it always has more work to do. If this happens, the garbage collector falls back to doing a full, non-incremental collection."),(0,o.kt)("p",null,"When Unity uses incremental garbage collection, it generates additional code (known as write barriers) to inform the garbage collector whenever a reference changes, so that it knows if it needs to rescan an object. This adds some overhead when ",(0,o.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/performance-memory-overview/performance-managed-memory#value-and-reference-types"},"changing references"),", which has a performance impact in managed code."),(0,o.kt)("p",null,"To disable Incremental Garbage Collection, open the Player Settings window ( ",(0,o.kt)("strong",{parentName:"p"},"Edit ",">"," Project Settings ",">"," Player ",">"," Configuration")," ) and disable  ",(0,o.kt)("strong",{parentName:"p"},"Use Incremental GC")," . Most Unity projects benefit from incremental garbage collection, especially if they suffer from garbage collection spikes, but you should always use the ",(0,o.kt)("a",{parentName:"p",href:"/doc-unity-manual/docs/profiler"},"Profiler")," to verify that your application performs as you expect."))}u.isMDXComponent=!0}}]);