"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[92017],{3905:function(e,t,a){a.d(t,{Zo:function(){return l},kt:function(){return u}});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var m=n.createContext({}),c=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},l=function(e){var t=c(e.components);return n.createElement(m.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,m=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),h=c(a),u=o,d=h["".concat(m,".").concat(u)]||h[u]||p[u]||r;return a?n.createElement(d,s(s({ref:t},l),{},{components:a})):n.createElement(d,s({ref:t},l))}));function u(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=h;var i={};for(var m in t)hasOwnProperty.call(t,m)&&(i[m]=t[m]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},64183:function(e,t,a){a.r(t),a.d(t,{assets:function(){return l},contentTitle:function(){return m},default:function(){return u},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return p}});var n=a(87462),o=a(63366),r=(a(67294),a(3905)),s=["components"],i={id:"performance-managed-memory",title:"Managed memory",slug:"/performance-memory-overview/performance-managed-memory"},m="Managed memory",c={unversionedId:"unity-overview/analysis/performance-memory-overview/performance-managed-memory",id:"unity-overview/analysis/performance-memory-overview/performance-managed-memory",title:"Managed memory",description:"Unity\u2019s  managed memory system  is a C# scripting environment based on the Mono or IL2CPP Virtual Machines (VMs). The benefit of the managed memory system is that it manages the release of memory, so you don\u2019t need to manually request the release of memory through your code.",source:"@site/docs/unity-overview/analysis/performance-memory-overview/performance-managed-memory.md",sourceDirName:"unity-overview/analysis/performance-memory-overview",slug:"/performance-memory-overview/performance-managed-memory",permalink:"/docs/performance-memory-overview/performance-managed-memory",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/unity-overview/analysis/performance-memory-overview/performance-managed-memory.md",tags:[],version:"current",frontMatter:{id:"performance-managed-memory",title:"Managed memory",slug:"/performance-memory-overview/performance-managed-memory"},sidebar:"tutorialSidebar",previous:{title:"Incremental garbage collection",permalink:"/docs/performance-garbage-collector/performance-incremental-garbage-collection"},next:{title:"Profiling tools",permalink:"/docs/performance-profiling-tools"}},l={},p=[{value:"Value and reference types",id:"value-and-reference-types",level:2},{value:"Automatic memory management",id:"automatic-memory-management",level:2},{value:"Managed heap overview",id:"managed-heap-overview",level:3},{value:"Memory fragmentation and heap expansion",id:"memory-fragmentation-and-heap-expansion",level:3},{value:"Managed heap expansion considerations",id:"managed-heap-expansion-considerations",level:3}],h={toc:p};function u(e){var t=e.components,a=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"managed-memory"},"Managed memory"),(0,r.kt)("p",null,"Unity\u2019s  ",(0,r.kt)("strong",{parentName:"p"},"managed memory system"),"  is a C# scripting environment based on the ",(0,r.kt)("a",{parentName:"p",href:"/docs/scripting-backends"},"Mono or IL2CPP Virtual Machines (VMs)"),". The benefit of the managed memory system is that it manages the release of memory, so you don\u2019t need to manually request the release of memory through your code."),(0,r.kt)("p",null,"Unity\u2019s managed memory system uses a ",(0,r.kt)("a",{parentName:"p",href:"/docs/performance-garbage-collector"},"garbage collector")," and a ",(0,r.kt)("a",{parentName:"p",href:"#managed-heap-overview"},"managed heap")," to automatically free memory allocations when your scripts no longer hold any references to those allocations. This helps safeguard against memory leaks. Memory leaks occur when memory is allocated, the reference to it is lost, and then the memory is never freed because it needs a ",(0,r.kt)("a",{parentName:"p",href:"#value-and-reference-types"},"reference")," to it to free it."),(0,r.kt)("p",null,"This memory management system also guards memory access, which means that you can\u2019t access memory that has been freed, or that was never valid for your code to access. However, this memory management process impacts runtime performance, because allocating managed memory is time-consuming for the CPU. ",(0,r.kt)("a",{parentName:"p",href:"/docs/performance-garbage-collector"},"Garbage collection")," might also stop the CPU from doing other work until it completes."),(0,r.kt)("h2",{id:"value-and-reference-types"},"Value and reference types"),(0,r.kt)("p",null,"When a method is called, the scripting back end copies the values of its parameters to an area of memory reserved for that specific call, in a data structure called a  ",(0,r.kt)("strong",{parentName:"p"},"call stack")," . The scripting back end can quickly copy data types that occupy a few bytes. However, it\u2019s common for objects, strings, and arrays to be much larger, and it\u2019s inefficient for the scripting back end to copy these types of data on a regular basis."),(0,r.kt)("p",null,"All non-null ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types"},"reference-type objects")," and all ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing"},"boxed value-typed objects")," in managed code must be allocated on the managed heap."),(0,r.kt)("p",null,"It\u2019s important that you are familiar with value and reference types, so that you can effectively manage your code. For more information, see Microsoft\u2019s documentation on ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types"},"value types"),", and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types"},"reference types"),"."),(0,r.kt)("h2",{id:"automatic-memory-management"},"Automatic memory management"),(0,r.kt)("p",null,"When an object is created, Unity allocates the memory required to store it from a central pool called  ",(0,r.kt)("strong",{parentName:"p"},"the heap")," , which is a section of memory that your Unity project\u2019s selected scripting runtime (Mono or IL2CPP) automatically manages. When an object is no longer in use, the memory it once occupied can be reclaimed and used for something else."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/scripting-backends"},"Unity\u2019s scripting back ends")," use a ",(0,r.kt)("a",{parentName:"p",href:"/docs/performance-garbage-collector"},"garbage collector")," to automatically manage your application\u2019s memory, so that you don\u2019t need to allocate and release these blocks of memory with explicit method calls. Automatic memory management requires less coding effort than explicit allocation/release and reduces the potential for memory leaks."),(0,r.kt)("h3",{id:"managed-heap-overview"},"Managed heap overview"),(0,r.kt)("p",null,"The  ",(0,r.kt)("strong",{parentName:"p"},"managed heap"),"  is a section of memory that your Unity project\u2019s selected scripting runtime (Mono or IL2CPP) automatically manages."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/managed-heap.jpg",alt:"A quantity of memory. Marked A on the diagram is some free memory."})),(0,r.kt)("p",null,"A quantity of memory. Marked A on the diagram is some free memory."),(0,r.kt)("p",null,"In the above diagram, the blue box represents a quantity of memory that Unity allocates to the managed heap. The white boxes within it represent data values that Unity stores within the managed heap\u2019s memory space. When additional data values are needed, Unity allocates them free space from the managed heap (annotated  ",(0,r.kt)("strong",{parentName:"p"},"A")," )."),(0,r.kt)("h3",{id:"memory-fragmentation-and-heap-expansion"},"Memory fragmentation and heap expansion"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/managed-heap-removed-objects.jpg",alt:"A quantity of memory, with some objects released represented by grey dashed lines."})),(0,r.kt)("p",null,"A quantity of memory, with some objects released represented by grey dashed lines."),(0,r.kt)("p",null,"The above diagram shows an example of memory fragmentation. When Unity releases an object, the memory that the object occupied is freed up. However, the free space doesn\u2019t become part of a single large pool of \u201cfree memory.\u201d"),(0,r.kt)("p",null,"The objects on either side of the released object might still be in use. Because of this, the freed space is a \u201cgap\u201d between other segments of memory. Unity can only use this gap to store data of identical or lesser size than the released object."),(0,r.kt)("p",null,"This situation is called  ",(0,r.kt)("strong",{parentName:"p"},"memory fragmentation")," . This happens when there is a large amount of memory available in the heap, but it is only available in the \u201cgaps\u201d between objects. This means that even though there is enough total space for a large memory allocation, the managed heap can\u2019t find a large enough single block of contiguous memory to assign to the allocation."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/managed-heap-fragmentation.jpg",alt:"The object annotated A, is the new object needed to be added to the heap. The items annotated B are the memory space that the released objects took up, plus the free, unreserved memory. Even though there is enough total free space, because there isnt enough contiguous space, the memory for the new object annotated A cant fit on the heap, and the garbage collector must run."})),(0,r.kt)("p",null,"The object annotated A, is the new object needed to be added to the heap. The items annotated B are the memory space that the released objects took up, plus the free, unreserved memory. Even though there is enough total free space, because there isn\u2019t enough contiguous space, the memory for the new object annotated A can\u2019t fit on the heap, and the garbage collector must run."),(0,r.kt)("p",null,"If a large object is allocated and there is insufficient contiguous free space to accommodate it, as illustrated above, the Unity memory manager performs two operations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"First, the garbage collector runs, if it hasn\u2019t already done so. This attempts to free up enough space to fulfill the allocation request."),(0,r.kt)("li",{parentName:"ul"},"If, after the garbage collector runs, there is still not enough contiguous space to fit the requested amount of memory, the heap must expand. The specific amount that the heap expands is platform-dependent; however, on most platforms, when the heap expands, it expands by double the amount of the previous expansion.")),(0,r.kt)("h3",{id:"managed-heap-expansion-considerations"},"Managed heap expansion considerations"),(0,r.kt)("p",null,"The unexpected expansion of the heap can be problematic. Unity\u2019s garbage collection strategy tends to fragment memory more often. You should be aware of the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Unity doesn\u2019t release the memory allocated to the managed heap when it expands regularly; instead, it retains the expanded heap, even if a large section of it is empty. This is to prevent the need to re-expand the heap if further large allocations occur."),(0,r.kt)("li",{parentName:"ul"},"On most platforms, Unity eventually releases the memory that the empty portions of the managed heap uses back to the operating system. The interval at which this happens isn\u2019t guaranteed and is unreliable.")))}u.isMDXComponent=!0}}]);