"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[97241],{3905:function(t,n,e){e.d(n,{Zo:function(){return f},kt:function(){return d}});var i=e(67294);function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function o(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,i)}return e}function a(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?o(Object(e),!0).forEach((function(n){r(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,i,r=function(t,n){if(null==t)return{};var e,i,r={},o=Object.keys(t);for(i=0;i<o.length;i++)e=o[i],n.indexOf(e)>=0||(r[e]=t[e]);return r}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(i=0;i<o.length;i++)e=o[i],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(r[e]=t[e])}return r}var l=i.createContext({}),u=function(t){var n=i.useContext(l),e=n;return t&&(e="function"==typeof t?t(n):a(a({},n),t)),e},f=function(t){var n=u(t.components);return i.createElement(l.Provider,{value:n},t.children)},c={inlineCode:"code",wrapper:function(t){var n=t.children;return i.createElement(i.Fragment,{},n)}},p=i.forwardRef((function(t,n){var e=t.components,r=t.mdxType,o=t.originalType,l=t.parentName,f=s(t,["components","mdxType","originalType","parentName"]),p=u(e),d=r,g=p["".concat(l,".").concat(d)]||p[d]||c[d]||o;return e?i.createElement(g,a(a({ref:n},f),{},{components:e})):i.createElement(g,a({ref:n},f))}));function d(t,n){var e=arguments,r=n&&n.mdxType;if("string"==typeof t||r){var o=e.length,a=new Array(o);a[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=t,s.mdxType="string"==typeof t?t:r,a[1]=s;for(var u=2;u<o;u++)a[u]=e[u];return i.createElement.apply(null,a)}return i.createElement.apply(null,e)}p.displayName="MDXCreateElement"},80287:function(t,n,e){e.r(n),e.d(n,{assets:function(){return f},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return c}});var i=e(87462),r=e(63366),o=(e(67294),e(3905)),a=["components"],s={id:"LightProbes-Placing-Scripting",title:"\u4f7f\u7528\u811a\u672c\u653e\u7f6e\u5149\u7167\u63a2\u9488",slug:"/light-probes/light-probes-placing-scripting"},l="\u4f7f\u7528\u811a\u672c\u653e\u7f6e\u5149\u7167\u63a2\u9488",u={unversionedId:"graphics/lighting-overview/light-probes/LightProbes-Placing-Scripting",id:"graphics/lighting-overview/light-probes/LightProbes-Placing-Scripting",title:"\u4f7f\u7528\u811a\u672c\u653e\u7f6e\u5149\u7167\u63a2\u9488",description:"\u624b\u52a8\u5927\u91cf\u653e\u7f6e\u5149\u7167\u63a2\u9488\u53ef\u80fd\u5341\u5206\u8017\u65f6\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u7f16\u5199\u81ea\u5df1\u7684\u7f16\u8f91\u5668\u811a\u672c\u6765\u81ea\u52a8\u653e\u7f6e\u5149\u7167\u63a2\u9488\u3002\u60a8\u7684\u811a\u672c\u53ef\u521b\u5efa\u5177\u6709 LightProbeGroup \u7ec4\u4ef6\u7684\u65b0\u6e38\u620f\u5bf9\u8c61\uff0c\u7136\u540e\u60a8\u53ef\u4ee5\u6839\u636e\u60a8\u9009\u62e9\u7f16\u7a0b\u7684\u4efb\u4f55\u89c4\u5219\u5355\u72ec\u6dfb\u52a0\u63a2\u9488\u4f4d\u7f6e\u3002",source:"@site/docs/graphics/lighting-overview/light-probes/light-probes-placing-scripting.md",sourceDirName:"graphics/lighting-overview/light-probes",slug:"/light-probes/light-probes-placing-scripting",permalink:"/doc-unity-manual/docs/light-probes/light-probes-placing-scripting",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/graphics/lighting-overview/light-probes/light-probes-placing-scripting.md",tags:[],version:"current",frontMatter:{id:"LightProbes-Placing-Scripting",title:"\u4f7f\u7528\u811a\u672c\u653e\u7f6e\u5149\u7167\u63a2\u9488",slug:"/light-probes/light-probes-placing-scripting"},sidebar:"tutorialSidebar",previous:{title:"\u7528\u4e8e\u79fb\u52a8\u5bf9\u8c61\u7684\u5149\u7167\u63a2\u9488",permalink:"/doc-unity-manual/docs/light-probes/light-probes-moving-objects"},next:{title:"\u5149\u7167\u63a2\u9488\uff1a\u6280\u672f\u4fe1\u606f",permalink:"/doc-unity-manual/docs/light-probes/light-probes-technical-information"}},f={},c=[],p={toc:c};function d(t){var n=t.components,e=(0,r.Z)(t,a);return(0,o.kt)("wrapper",(0,i.Z)({},p,e,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"\u4f7f\u7528\u811a\u672c\u653e\u7f6e\u5149\u7167\u63a2\u9488"},"\u4f7f\u7528\u811a\u672c\u653e\u7f6e\u5149\u7167\u63a2\u9488"),(0,o.kt)("p",null,"\u624b\u52a8\u5927\u91cf\u653e\u7f6e\u5149\u7167\u63a2\u9488\u53ef\u80fd\u5341\u5206\u8017\u65f6\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u7f16\u5199\u81ea\u5df1\u7684\u7f16\u8f91\u5668\u811a\u672c\u6765\u81ea\u52a8\u653e\u7f6e\u5149\u7167\u63a2\u9488\u3002\u60a8\u7684\u811a\u672c\u53ef\u521b\u5efa\u5177\u6709 LightProbeGroup \u7ec4\u4ef6\u7684\u65b0\u6e38\u620f\u5bf9\u8c61\uff0c\u7136\u540e\u60a8\u53ef\u4ee5\u6839\u636e\u60a8\u9009\u62e9\u7f16\u7a0b\u7684\u4efb\u4f55\u89c4\u5219\u5355\u72ec\u6dfb\u52a0\u63a2\u9488\u4f4d\u7f6e\u3002"),(0,o.kt)("p",null,"\u4f8b\u5982\uff0c\u4ee5\u4e0b\u811a\u672c\u53ef\u5c06\u5149\u7167\u63a2\u9488\u653e\u7f6e\u5728\u5706\u5f62\u6216\u5706\u73af\u4e2d\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"using UnityEngine;\nusing System.Collections.Generic;\n\n[RequireComponent (typeof (LightProbeGroup))]\npublic class LightProbesTetrahedralGrid : MonoBehaviour\n{\n // \u516c\u7528\n public float m_Side = 1.0f;\n public float m_Radius = 5.0f;\n public float m_InnerRadius = 0.1f;\n public float m_Height = 2.0f;\n public uint m_Levels = 3;\n const float kMinSide = 0.05f;\n const float kMinHeight = 0.05f;\n const float kMinInnerRadius = 0.1f;\n const uint kMinIterations = 4;\n public void OnValidate ()\n {\n  m_Side = Mathf.Max (kMinSide, m_Side);\n  m_Height = Mathf.Max (kMinHeight, m_Height);\n  if (m_InnerRadius &lt; kMinInnerRadius)\n  {\n   TriangleProps props = new TriangleProps (m_Side);\n   m_Radius = Mathf.Max (props.circumscribedCircleRadius + 0.01f, m_Radius);\n  }\n  else\n  {\n   m_Radius = Mathf.Max (0.1f, m_Radius);\n   m_InnerRadius = Mathf.Min (m_Radius, m_InnerRadius);\n  }\n }\n struct TriangleProps\n {\n  public TriangleProps (float triangleSide)\n  {\n   side = triangleSide;\n   halfSide = side / 2.0f;\n   height = Mathf.Sqrt (3.0f) * side / 2.0f;\n   inscribedCircleRadius = Mathf.Sqrt (3.0f) * side / 6.0f;\n   circumscribedCircleRadius = 2.0f * height / 3.0f;\n  }\n  public float side;\n  public float halfSide;\n  public float height;\n  public float inscribedCircleRadius;\n  public float circumscribedCircleRadius;\n };\n\n private TriangleProps m_TriangleProps;\n public void Generate ()\n {\n  LightProbeGroup lightProbeGroup = GetComponent&lt;LightProbeGroup&gt; ();\n  List&lt;Vector3&gt; positions = new List&lt;Vector3&gt; ();\n  m_TriangleProps = new TriangleProps (m_Side);\n  if (m_InnerRadius &lt; kMinInnerRadius)\n   GenerateCylinder (m_TriangleProps, m_Radius, m_Height, m_Levels, positions);\n  else\n   GenerateRing (m_TriangleProps, m_Radius, m_InnerRadius, m_Height, m_Levels, positions);\n  lightProbeGroup.probePositions = positions.ToArray ();\n }\n static void AttemptAdding (Vector3 position, Vector3 center, float distanceCutoffSquared, List&lt;Vector3&gt; outPositions)\n {\n  if ((position - center).sqrMagnitude &lt; distanceCutoffSquared)\n   outPositions.Add (position);\n }\n uint CalculateCylinderIterations (TriangleProps props, float radius)\n {\n  int iterations = Mathf.CeilToInt ((radius + props.height - props.inscribedCircleRadius) / props.height);\n  if (iterations &gt; 0)\n   return (uint)iterations;\n  return 0;\n }\n void GenerateCylinder (TriangleProps props, float radius, float height, uint levels, List&lt;Vector3&gt; outPositions)\n {\n  uint iterations = CalculateCylinderIterations (props, radius);\n  float distanceCutoff = radius;\n  float distanceCutoffSquared = distanceCutoff * distanceCutoff;\n  Vector3 up = new Vector3 (props.circumscribedCircleRadius, 0.0f, 0.0f);\n  Vector3 leftDown = new Vector3 (-props.inscribedCircleRadius, 0.0f, -props.halfSide);\n  Vector3 rightDown = new Vector3 (-props.inscribedCircleRadius, 0.0f, props.halfSide);\n  for (uint l = 0; l &lt; levels; l++)\n  {\n   float tLevel = levels == 1 ? 0 : (float)l / (float)(levels - 1);\n   Vector3 center = new Vector3 (0.0f, tLevel * height, 0.0f);\n   if (l % 2 == 0)\n   {\n    for (uint i = 0; i &lt; iterations; i++)\n    {\n     Vector3 upCorner = center + up + (float)i * up * 2.0f * 3.0f / 2.0f;\n     Vector3 leftDownCorner = center + leftDown + (float)i * leftDown * 2.0f * 3.0f / 2.0f;\n     Vector3 rightDownCorner = center + rightDown + (float)i * rightDown * 2.0f * 3.0f / 2.0f;\n     AttemptAdding (upCorner, center, distanceCutoffSquared, outPositions);\n     AttemptAdding (leftDownCorner, center, distanceCutoffSquared, outPositions);\n     AttemptAdding (rightDownCorner, center, distanceCutoffSquared, outPositions);\n     Vector3 leftDownUp = upCorner - leftDownCorner;\n     Vector3 upRightDown = rightDownCorner - upCorner;\n     Vector3 rightDownLeftDown = leftDownCorner - rightDownCorner;\n     uint subdiv = 3 * i + 1;\n     for (uint s = 1; s &lt; subdiv; s++)\n     {\n      Vector3 leftDownUpSubdiv = leftDownCorner + leftDownUp * (float)s / (float)subdiv;\n      AttemptAdding (leftDownUpSubdiv, center, distanceCutoffSquared, outPositions);\n      Vector3 upRightDownSubdiv = upCorner + upRightDown * (float)s / (float)subdiv;\n      AttemptAdding (upRightDownSubdiv, center, distanceCutoffSquared, outPositions);\n      Vector3 rightDownLeftDownSubdiv = rightDownCorner + rightDownLeftDown * (float)s / (float)subdiv;\n      AttemptAdding (rightDownLeftDownSubdiv, center, distanceCutoffSquared, outPositions);\n     }\n    }\n   }\n   else\n   {\n    for (uint i = 0; i &lt; iterations; i++)\n    {\n     Vector3 upCorner = center + (float)i * (2.0f * up * 3.0f / 2.0f);\n     Vector3 leftDownCorner = center + (float)i * (2.0f * leftDown * 3.0f / 2.0f);\n     Vector3 rightDownCorner = center + (float)i * (2.0f * rightDown * 3.0f / 2.0f);\n     AttemptAdding (upCorner, center, distanceCutoffSquared, outPositions);\n     AttemptAdding (leftDownCorner, center, distanceCutoffSquared, outPositions);\n     AttemptAdding (rightDownCorner, center, distanceCutoffSquared, outPositions);\n     Vector3 leftDownUp = upCorner - leftDownCorner;\n     Vector3 upRightDown = rightDownCorner - upCorner;\n     Vector3 rightDownLeftDown = leftDownCorner - rightDownCorner;\n     uint subdiv = 3 * i;\n     for (uint s = 1; s &lt; subdiv; s++)\n     {\n      Vector3 leftDownUpSubdiv = leftDownCorner + leftDownUp * (float)s / (float)subdiv;\n      AttemptAdding (leftDownUpSubdiv, center, distanceCutoffSquared, outPositions);\n      Vector3 upRightDownSubdiv = upCorner + upRightDown * (float)s / (float)subdiv;\n      AttemptAdding (upRightDownSubdiv, center, distanceCutoffSquared, outPositions);\n      Vector3 rightDownLeftDownSubdiv = rightDownCorner + rightDownLeftDown * (float)s / (float)subdiv;\n      AttemptAdding (rightDownLeftDownSubdiv, center, distanceCutoffSquared, outPositions);\n     }\n    }\n   }\n  }\n }\n void GenerateRing (TriangleProps props, float radius, float innerRadius, float height, uint levels, List&lt;Vector3&gt; outPositions)\n {\n  float chordLength = props.side;\n  float angle = Mathf.Clamp (2.0f * Mathf.Asin (chordLength / (2.0f * radius)), 0.01f, 2.0f * Mathf.PI);\n  uint slicesAtRadius = (uint)Mathf.FloorToInt (2.0f * Mathf.PI / angle);\n  uint layers = (uint)Mathf.Max (Mathf.Ceil ((radius - innerRadius) / props.height), 0.0f);\n  for (uint level = 0; level &lt; levels; level++)\n  {\n   float tLevel = levels == 1 ? 0 : (float)level / (float)(levels - 1);\n   float y = height * tLevel;\n   float iterationOffset0 = level % 2 == 0 ? 0.0f : 0.5f;\n   for (uint layer = 0; layer &lt; layers; layer++)\n   {\n    float tLayer = layers == 1 ? 1.0f : (float)layer / (float)(layers - 1);\n    float tIterations = (tLayer * (radius - innerRadius) + innerRadius - kMinInnerRadius) / (radius - kMinInnerRadius);\n    uint slices = (uint)Mathf.CeilToInt (Mathf.Lerp (kMinIterations, slicesAtRadius, tIterations));\n    float x = innerRadius + (radius - innerRadius) * tLayer;\n    Vector3 position = new Vector3 (x, y, 0.0f);\n    float layerSliceOffset = layer % 2 == 0 ? 0.0f : 0.5f;\n    for (uint slice = 0; slice &lt; slices; slice++)\n    {\n     Quaternion rotation = Quaternion.Euler (0.0f, (slice + iterationOffset0 + layerSliceOffset) * 360.0f / (float)slices, 0.0f);\n     outPositions.Add (rotation * position);\n    }\n   }\n  }\n }\n}\n")),(0,o.kt)("hr",null),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"2017\u201306\u201308 \u9875\u9762\u5df2\u53d1\u5e03"),(0,o.kt)("li",{parentName:"ul"},"\u5728 5.6 \u7248\u66f4\u65b0\u4e86\u5149\u7167\u63a2\u9488")))}d.isMDXComponent=!0}}]);