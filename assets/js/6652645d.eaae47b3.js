"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[64e3],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),p=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=a,h=m["".concat(o,".").concat(d)]||m[d]||c[d]||i;return n?r.createElement(h,s(s({ref:t},u),{},{components:n})):r.createElement(h,s({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var p=2;p<i;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},53292:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var r=n(87462),a=n(63366),i=(n(67294),n(3905)),s=["components"],l={id:"ManagedCodeStripping",title:"\u6258\u7ba1\u4ee3\u7801\u5265\u79bb",slug:"/scripting-backends/managed-code-stripping"},o="\u6258\u7ba1\u4ee3\u7801\u5265\u79bb",p={unversionedId:"scripting-section/unity-architecture/scripting-backends/ManagedCodeStripping",id:"scripting-section/unity-architecture/scripting-backends/ManagedCodeStripping",title:"\u6258\u7ba1\u4ee3\u7801\u5265\u79bb",description:"During the build process, Unity removes unused or unreachable code through a process called managed code stripping, which can significantly decrease your application\u2019s final size. Managed code stripping removes code from managed assemblies, including assemblies built from the C# scripts in your project, assemblies that are part of packages and plugins, and assemblies in .NET Framework.",source:"@site/docs/scripting-section/unity-architecture/scripting-backends/managed-code-stripping.md",sourceDirName:"scripting-section/unity-architecture/scripting-backends",slug:"/scripting-backends/managed-code-stripping",permalink:"/docs/scripting-backends/managed-code-stripping",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/scripting-section/unity-architecture/scripting-backends/managed-code-stripping.md",tags:[],version:"current",frontMatter:{id:"ManagedCodeStripping",title:"\u6258\u7ba1\u4ee3\u7801\u5265\u79bb",slug:"/scripting-backends/managed-code-stripping"},sidebar:"tutorialSidebar",previous:{title:"Linux IL2CPP \u4ea4\u53c9\u7f16\u8bd1\u5668",permalink:"/docs/il2cpp/linux-il2cppcrosscompiler"},next:{title:"Mono overview",permalink:"/docs/scripting-backends/mono"}},u={},c=[{value:"Configure managed code stripping",id:"configure-managed-code-stripping",level:2},{value:"Preserve code using annotations",id:"preserve-code-using-annotations",level:2},{value:"Root annotations",id:"root-annotations",level:2},{value:"Annotate roots using the Preserve attribute",id:"annotate-roots-using-the-preserve-attribute",level:3},{value:"Annotate roots using a Link XML file",id:"annotate-roots-using-a-link-xml-file",level:3},{value:"Additional Assembly XML attributes",id:"additional-assembly-xml-attributes",level:3},{value:"Dependency annotations",id:"dependency-annotations",level:2},{value:"Annotation attributes",id:"annotation-attributes",level:3},{value:"AlwaysLinkAssembly \u5c5e\u6027",id:"alwayslinkassembly-\u5c5e\u6027",level:3}],m={toc:c};function d(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"\u6258\u7ba1\u4ee3\u7801\u5265\u79bb"},"\u6258\u7ba1\u4ee3\u7801\u5265\u79bb"),(0,i.kt)("p",null,"During the build process, Unity removes unused or unreachable code through a process called managed code stripping, which can significantly decrease your application\u2019s final size. Managed code stripping removes code from managed assemblies, including assemblies built from the C# scripts in your project, assemblies that are part of packages and plugins, and assemblies in .NET Framework."),(0,i.kt)("p",null,"Unity uses a tool called the Unity linker to perform a static analysis of the code in your project\u2019s assemblies. The static analysis identifies any classes, portions of classes, functions, or portions of functions that can\u2019t be reached during execution. This analysis only includes code that exists at build time because runtime generated code doesn\u2019t exist when Unity performs the static analysis."),(0,i.kt)("p",null,"You can configure the level of code stripping Unity performs for your project using the  ",(0,i.kt)("strong",{parentName:"p"},"Managed Stripping Level"),"  setting. To prevent Unity removing specific parts of your code, use annotations to indicate which parts of your code base the Unity linker should preserve. For more information, see ",(0,i.kt)("a",{parentName:"p",href:"#unity-linker"},"Unity linker"),"."),(0,i.kt)("h2",{id:"configure-managed-code-stripping"},"Configure managed code stripping"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/managed-code-stripping-level.png",alt:"The Managed Stripping Level property"})),(0,i.kt)("p",null,"The Managed Stripping Level property"),(0,i.kt)("p",null,"The  ",(0,i.kt)("strong",{parentName:"p"},"Managed Stripping Level"),"  property determines the set of rules that the Unity linker follows when it analyzes and strips your application\u2019s code. As you increase the setting from  ",(0,i.kt)("strong",{parentName:"p"},"Minimal"),"  to  ",(0,i.kt)("strong",{parentName:"p"},"High")," , the rules enable the linker to search through more assemblies for unreachable code. The Unity linker removes more code at the higher settings which reduces the final size of your build, though the expanded search means that each build takes longer to produce."),(0,i.kt)("p",null,"To change the  ",(0,i.kt)("strong",{parentName:"p"},"Managed Stripping Level"),"  property:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Go to  ",(0,i.kt)("strong",{parentName:"li"},"Edit"),"  ",">","  ",(0,i.kt)("strong",{parentName:"li"},"Project Settings"),"  ",">","  ",(0,i.kt)("strong",{parentName:"li"},"Player")," ."),(0,i.kt)("li",{parentName:"ol"},"In Other Settings, navigate to the Optimization heading."),(0,i.kt)("li",{parentName:"ol"},"Set the  ",(0,i.kt)("strong",{parentName:"li"},"Managed Stripping Level"),"  property to the desired value.")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u5c5e\u6027\uff1a")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u529f\u80fd\uff1a")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Disabled")),(0,i.kt)("td",{parentName:"tr",align:null},"Unity doesn\u2019t remove any code.",(0,i.kt)("br",null),(0,i.kt)("br",null),"This setting is visible only and is the default setting if you use the Mono scripting backend.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Minimal")),(0,i.kt)("td",{parentName:"tr",align:null},"Unity searches only the UnityEngine and the .NET class libraries for unused code. Unity doesn\u2019t remove any user-written code. This setting is the least likely to cause any unexpected runtime behavior.",(0,i.kt)("br",null),(0,i.kt)("br",null),"This setting is useful for projects where usability is of higher priority than build size.This is the default setting if you use the IL2CPP scripting backend.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Low")),(0,i.kt)("td",{parentName:"tr",align:null},"Unity searches some user-written assemblies and all UnityEngine and .NET class libraries for unused code. This setting applies a set of rules that removes some unused code but minimizes the likelihood of unintended consequences, such as changes in behavior of runtime code that uses reflection.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Medium")),(0,i.kt)("td",{parentName:"tr",align:null},"Unity partially searches all assemblies to find unreachable code. This setting applies a set of rules that strips more types of code patterns to reduce the build size. Although Unity doesn\u2019t strip all possible unreachable code, this setting does increase the risk of undesirable or unexpected behavior changes.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"High")),(0,i.kt)("td",{parentName:"tr",align:null},"Unity performs an extensive search of all assemblies to find unreachable code. At this setting, Unity prioritizes size reduction more than code stability and removes as much code as possible.",(0,i.kt)("br",null),(0,i.kt)("br",null),"This search can take much longer than for lower stripping levels. Use this setting only for projects where a compact build size is extremely important. Test your application thoroughly and make careful use of ","[","Preserve","]"," attributes and link.xml files to ensure that the Unity linker doesn\u2019t strip vital code.")))),(0,i.kt)("h2",{id:"preserve-code-using-annotations"},"Preserve code using annotations"),(0,i.kt)("p",null,"You can use annotations to prevent the Unity linker from stripping specific sections of your code. This is helpful if your application produces runtime code which doesn\u2019t exist when Unity performs the static analysis; for example, through ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection"},"reflection"),". Annotations either provide general guidance to the Unity linker about which code patterns it shouldn\u2019t strip, or instructions not to strip a specific, defined section of code."),(0,i.kt)("p",null,"There are two broad approaches you can use to annotate your code to preserve it from the managed code stripping process:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Root annotations identify parts of your code as roots. The Unity linker doesn\u2019t strip any code that is marked as a root. Root annotations are less complicated to use but can also lead to the Unity linker preserving some code that it should strip."),(0,i.kt)("li",{parentName:"ul"},"Dependency annotations define the connections between code elements. Dependency annotations can reduce the amount of over preservation of code compared to root annotations.")),(0,i.kt)("p",null,"Each of these techniques provides more control over the amount of code that the Unity linker strips at higher stripping levels and reduces the chance of vital code being stripped. Annotations are especially useful when your code references other code through reflection, because the Unity linker can\u2019t always detect uses of reflection."),(0,i.kt)("p",null,"Preserve code that uses reflection or generates other code at runtime to significantly reduce the likelihood of unexpected behavior when your application is executed. For examples of reflection patterns that the Unity linker can recognize, see the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Unity-Technologies/linker/tree/unity-master/test/Mono.Linker.Tests.Cases/Reflection"},"Unity Intermediate Language Linker reflection test suite"),"."),(0,i.kt)("h2",{id:"root-annotations"},"Root annotations"),(0,i.kt)("p",null,"Root annotations force the Unity linker to treat code elements as roots, which aren\u2019t stripped in the code stripping process. There are two types of root annotations you can use, depending on whether you need to preserve individual types with their constructors or assemblies:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#annotate-roots-using-the-preserve-attribute"},"Preserve Attribute"),": Annotates individual types as roots to preserve them."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#annotate-roots-using-a-link-xml-file"},"Link.xml"),": Annotates assemblies and any types or other code entities within those assemblies as roots to preserve them.")),(0,i.kt)("h3",{id:"annotate-roots-using-the-preserve-attribute"},"Annotate roots using the Preserve attribute"),(0,i.kt)("p",null,"Use the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Scripting.html"},"Preserve")," attribute to individually exclude specific sections of your code from the Unity linker\u2019s static analysis. To annotate a piece of code with this attribute, add ",(0,i.kt)("inlineCode",{parentName:"p"},"[Preserve]")," immediately before the first part of the code you want to preserve. The following list describes what entities the Unity linker preserves when you annotate different code elements with the ",(0,i.kt)("inlineCode",{parentName:"p"},"[Preserve]")," attribute:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Assembly")," : Preserves all types that are used and defined in the assembly. To assign the ",(0,i.kt)("inlineCode",{parentName:"li"},"[Preserve]")," attribute to an assembly, place the attribute declaration in any C# file included in the assembly, before any namespace declarations."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Type")," : Preserves a class or type and its default constructor."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Method")," : Preserves the method, the type that declares the method, the type the method returns, and the types of all of its arguments."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Property")," : Preserves the property, the type that declares the property, the value type of the property, and methods that get and set the property value."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Field")," : Preserves the field, the field type, and the type that declares the field."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Event")," : Preserves the event, the type that declares the event, type, the type the event returns, the ",(0,i.kt)("inlineCode",{parentName:"li"},"[add]")," accessor, and the ",(0,i.kt)("inlineCode",{parentName:"li"},"[remove]")," accessor."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Delegate")," : Preserves the delegate type and all methods that the delegate invokes.")),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"[Preserve]")," attribute when you want to preserve both a type and its default constructor. If you want to keep one or the other but not both, use a link.xml file."),(0,i.kt)("p",null,"You can define the ",(0,i.kt)("inlineCode",{parentName:"p"},"[Preserve]")," attribute in any assembly and in any namespace. You can use the UnityEngine.Scripting.PreserveAttribute class, create a subclass of UnityEngine.Scripting.PreserveAttribute, or create your own ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/ScriptReference/PreserveAttribute.html"},"PreserveAttribute")," class. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Foo\n{\n    [Preserve]\n    public void PreservedMethod(){}\n}\n")),(0,i.kt)("h3",{id:"annotate-roots-using-a-link-xml-file"},"Annotate roots using a Link XML file"),(0,i.kt)("p",null,"You can include a .xml file entitled link.xml in your project to preserve a list of specific assemblies or parts of assemblies. The link.xml file must be present in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Assets")," folder or a subdirectory of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Assets")," folder in your project and must include the ",(0,i.kt)("inlineCode",{parentName:"p"},"&lt;linker&gt;")," tag in the file. The Unity linker treats any assembly, type, or member preserved in a link.xml file as a root type."),(0,i.kt)("p",null,"You can use any number of link.xml files in your project. As a result, you can provide separate preservation declarations for each plugin. You can\u2019t include a link.xml file in a package, but you can reference package assemblies from non-package link.xml files."),(0,i.kt)("p",null,"The following examples illustrate the different ways that you can declare the root types of a project\u2019s assemblies using a link.xml file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'&lt;linker&gt;\n  &lt;!--Preserve types and members in an assembly--&gt;\n  &lt;assembly fullname="AssemblyName"&gt;\n    &lt;!--Preserve an entire type--&gt;\n    &lt;type fullname="AssemblyName.MethodName" preserve="all"/&gt;\n\n    &lt;!--No "preserve" attribute and no members specified means preserve all members--&gt;\n    &lt;type fullname="AssemblyName.MethodName"/&gt;\n\n    &lt;!--Preserve all fields on a type--&gt;\n    &lt;type fullname="AssemblyName.MethodName" preserve="fields"/&gt;\n\n    &lt;!--Preserve all fields on a type--&gt;\n    &lt;type fullname="AssemblyName.MethodName" preserve="methods"/&gt;\n\n    &lt;!--Preserve the type only--&gt;\n    &lt;type fullname="AssemblyName.MethodName" preserve="nothing"/&gt;\n\n    &lt;!--Preserving only specific members of a type--&gt;\n    &lt;type fullname="AssemblyName.MethodName"&gt;\n        \n      &lt;!--Fields--&gt;\n      &lt;field signature="System.Int32 FieldName" /&gt;\n\n      &lt;!--Preserve a field by name rather than signature--&gt;\n      &lt;field name="FieldName" /&gt;\n      \n      &lt;!--Methods--&gt;\n      &lt;method signature="System.Void MethodName()" /&gt;\n\n      &lt;!--Preserve a method with parameters--&gt;\n      &lt;method signature="System.Void MethodName(System.Int32,System.String)" /&gt;\n\n      &lt;!--Preserve a method by name rather than signature--&gt;\n      &lt;method name="MethodName" /&gt;\n\n      &lt;!--Properties--&gt;\n\n      &lt;!--Preserve a property, it\'s backing field (if present), \n          getter, and setter methods--&gt;\n      &lt;property signature="System.Int32 PropertyName" /&gt;\n\n      &lt;property signature="System.Int32 PropertyName" accessors="all" /&gt;\n\n      &lt;!--Preserve a property, it\'s backing field (if present), and getter method--&gt;\n      &lt;property signature="System.Int32 PropertyName" accessors="get" /&gt;\n\n      &lt;!--Preserve a property, it\'s backing field (if present), and setter method--&gt;\n      &lt;property signature="System.Int32 PropertyName" accessors="set" /&gt;\n\n      &lt;!--Preserve a property by name rather than signature--&gt;\n      &lt;property name="PropertyName" /&gt;\n\n      &lt;!--Events--&gt;\n\n      &lt;!--Preserve an event, it\'s backing field (if present), add, and remove methods--&gt;\n      &lt;event signature="System.EventHandler EventName" /&gt;\n\n      &lt;!--Preserve an event by name rather than signature--&gt;\n      &lt;event name="EventName" /&gt;\n\n    &lt;/type&gt;\n  &lt;/assembly&gt;\n&lt;/linker&gt;\n')),(0,i.kt)("p",null,"The next example shows how you can declare entire assemblies:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'&lt;!--Preserve an entire assembly--&gt;\n  &lt;assembly fullname="AssemblyName" preserve="all"/&gt;\n\n  &lt;!--No "preserve" attribute and no types specified means preserve all--&gt;\n  &lt;assembly fullname="AssemblyName"/&gt;\n\n  &lt;!--Fully qualified assembly name--&gt;\n  &lt;assembly fullname="AssemblyName, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null"&gt;\n    &lt;type fullname="AssemblyName.Foo" preserve="all"/&gt;\n  &lt;/assembly&gt;\n\n  &lt;!--Force an assembly to be processed for roots but don\u2019t explicitly preserve anything in particular. Useful when the assembly isn\'t referenced.--&gt;\n  &lt;assembly fullname="AssemblyName" preserve="nothing"/&gt;\n')),(0,i.kt)("p",null,"This example shows how to preserve either nested or generic types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'&lt;!--Examples with generics--&gt;\n    &lt;type fullname="AssemblyName.G`1"&gt;\n\n      &lt;!--Preserve a field with generics in the signature--&gt;\n      &lt;field signature="System.Collections.Generic.List`1&lt;System.Int32&gt; FieldName" /&gt;\n\n      &lt;field signature="System.Collections.Generic.List`1&lt;T&gt; FieldName" /&gt;\n\n      &lt;!--Preserve a method with generics in the signature--&gt;\n      &lt;method signature="System.Void MethodName(System.Collections.Generic.List`1&lt;System.Int32&gt;)" /&gt;\n\n      &lt;!--Preserve an event with generics in the signature--&gt;\n      &lt;event signature="System.EventHandler`1&lt;System.EventArgs&gt; EventName" /&gt;\n\n    &lt;/type&gt;\n\n    &lt;!--Preserve a nested type--&gt;\n    &lt;type fullname="AssemblyName.H/Nested" preserve="all"/&gt;\n\n    &lt;!--Preserve all fields of a type if the type is used.  If the type isn\'t used, it will be removed--&gt;\n    &lt;type fullname="AssemblyName.I" preserve="fields" required="0"/&gt;\n\n    &lt;!--Preserve all methods of a type if the type is used. If the type isn\'t used, it will be removed--&gt;\n    &lt;type fullname="AssemblyName.J" preserve="methods" required="0"/&gt;\n\n    &lt;!--Preserve all types in a namespace--&gt;\n    &lt;type fullname="AssemblyName.SomeNamespace*" /&gt;\n\n    &lt;!--Preserve all types with a common prefix in their name--&gt;\n    &lt;type fullname="Prefix*" /&gt;\n')),(0,i.kt)("h3",{id:"additional-assembly-xml-attributes"},"Additional Assembly XML attributes"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"&lt;assembly&gt;")," element of the link.xml file has three special-purpose attributes that you can enable for more control over the annotations."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignoreIfMissing"),": Use this attribute if you need to declare preservations for an assembly that doesn\u2019t exist during all Player builds.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'&lt;linker&gt;\n  &lt;assembly fullname="Foo" ignoreIfMissing="1"&gt;\n    &lt;type name="TypeName"/&gt;\n  &lt;/assembly&gt;\n&lt;/linker&gt;\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignoreIfUnreferenced:")," In some cases, you might want to preserve entities in an assembly only when that assembly is referenced by another assembly. Use this attribute to preserve the entities in an assembly only when at least one type is referenced in an assembly.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'&lt;linker&gt;\n  &lt;assembly fullname="Bar" ignoreIfUnreferenced="1"&gt;\n    &lt;type name="TypeName"/&gt;\n  &lt;/assembly&gt;\n&lt;/linker&gt;\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"windowsruntime:")," When you define preservations for a Windows Runtime Metadata (.winmd) assembly, you must add the ",(0,i.kt)("inlineCode",{parentName:"li"},"windowsruntime")," attribute to the ",(0,i.kt)("inlineCode",{parentName:"li"},"&lt;assembly&gt;")," element in the link.xml file:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'&lt;linker&gt;\n  &lt;assembly fullname="Windows" windowsruntime="true"&gt;\n    &lt;type name="TypeName"/&gt;\n &lt;/assembly&gt;\n&lt;/linker&gt;\n')),(0,i.kt)("h2",{id:"dependency-annotations"},"Dependency annotations"),(0,i.kt)("p",null,"Dependency annotations define dependencies between various code elements. These annotations are useful for preserving code patterns that the Unity linker can\u2019t statically analyze, such as reflection. These annotations also ensure that these code elements aren\u2019t erroneously preserved when no root element uses them. There are two methods you can use to change how the Unity linker processes code elements:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#annotation-attributes"},"Annotation attributes"),": these attributes indicate that the Unity linker should preserve a particular code pattern, such as any type that derives from the annotated type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#always-link-assembly-%E5%B1%9E%E6%80%A7"},"AlwaysLinkAssemblyAttribute"),": use this attribute to indicate that the Unity linker should process an assembly even if it\u2019s not referenced by any other assemblies in your Project.")),(0,i.kt)("h3",{id:"annotation-attributes"},"Annotation attributes"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"[Preserve]")," attribute is useful for situations when an API is always needed. Other attributes can be useful for more general preservations. For example, you can preserve all types that implement a particular interface by annotating the interface with the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Scripting.RequireImplementorsAttribute.html"},"RequireImplementorsAttribute"),"."),(0,i.kt)("p",null,"To annotate specific coding patterns, use one or more of the following attributes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/Scripting.RequireImplementorsAttribute.html"},"RequireImplementorsAttribute"),": marks all types that implement this interface as dependencies."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/scripting.RequireDerivedAttribute.html"},"RequireDerivedAttribute"),": marks all types that derive from this type as dependencies."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/scripting.RequiredInterfaceAttribute.html"},"RequiredInterfaceAttribute"),": marks interface implementations on types as dependencies."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/scripting.RequiredMemberAttribute.html"},"RequiredMemberAttribute"),": marks all members of a type as dependencies."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/scripting.html"},"RequireAttributeUsagesAttribute"),": marks custom attributes as dependencies.")),(0,i.kt)("p",null,"You can combine these attributes in various ways to more precisely control how the Unity linker preserves your code."),(0,i.kt)("h3",{id:"alwayslinkassembly-\u5c5e\u6027"},"AlwaysLinkAssembly \u5c5e\u6027"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"[assembly: UnityEngine.Scripting.AlwaysLinkAssembly]")," attribute forces the Unity linker to search an assembly regardless of whether or not the assembly is referenced by another assembly that is included in the build. You can apply the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/scripting.AlwaysLinkAssemblyAttribute.html"},"AlwaysLinkAssembly")," attribute only to an assembly."),(0,i.kt)("p",null,"The attribute doesn\u2019t directly preserve code within the assembly. Instead, this attribute instructs the Unity linker to apply the root marking rules to the assembly. If no code elements match the root marking rules for the assembly, the Unity linker still removes the assembly from the build."),(0,i.kt)("p",null,"Use this attribute on precompiled or package assemblies that contain one or more methods with the ",(0,i.kt)("inlineCode",{parentName:"p"},"[RuntimeInitializeOnLoadMethod]")," attribute, but which might not contain types used directly or indirectly in any Scenes in a project."),(0,i.kt)("p",null,"If an assembly defines ",(0,i.kt)("inlineCode",{parentName:"p"},"[assembly: AlwaysLinkAssembly]")," and is also referenced by another assembly included in the build, the attribute has no effect on the output."))}d.isMDXComponent=!0}}]);