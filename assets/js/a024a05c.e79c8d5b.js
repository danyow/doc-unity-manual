"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[46735],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),o=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=o(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),h=o(a),d=n,u=h["".concat(s,".").concat(d)]||h[d]||m[d]||i;return a?r.createElement(u,l(l({ref:t},p),{},{components:a})):r.createElement(u,l({ref:t},p))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:n,l[1]=c;for(var o=2;o<i;o++)l[o]=a[o];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}h.displayName="MDXCreateElement"},2352:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return c},metadata:function(){return o},toc:function(){return m}});var r=a(87462),n=a(63366),i=(a(67294),a(3905)),l=["components"],c={id:"DrawCallBatching",title:"Draw call batching",slug:"/draw-call-batching"},s="Draw call batching",o={unversionedId:"graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/DrawCallBatching",id:"graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/DrawCallBatching",title:"Draw call batching",description:"Draw call batching is a draw call optimization method that combines meshes so that Unity can render them in fewer draw calls. Unity provides two built-in draw call batching methods:",source:"@site/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching.md",sourceDirName:"graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching",slug:"/draw-call-batching",permalink:"/docs/draw-call-batching",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching.md",tags:[],version:"current",frontMatter:{id:"DrawCallBatching",title:"Draw call batching",slug:"/draw-call-batching"},sidebar:"tutorialSidebar",previous:{title:"Manually combining meshes",permalink:"/docs/optimizing-draw-calls/combining-meshes"},next:{title:"Dynamic batching",permalink:"/docs/draw-call-batching/dynamic-batching"}},p={},m=[{value:"Requirements and compatibility",id:"requirements-and-compatibility",level:2},{value:"Render pipeline compatibility",id:"render-pipeline-compatibility",level:3},{value:"Using draw call batching",id:"using-draw-call-batching",level:2}],h={toc:m};function d(e){var t=e.components,a=(0,n.Z)(e,l);return(0,i.kt)("wrapper",(0,r.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"draw-call-batching"},"Draw call batching"),(0,i.kt)("p",null,"Draw call batching is a ",(0,i.kt)("a",{parentName:"p",href:"/docs/optimizing-draw-calls"},"draw call optimization")," method that combines meshes so that Unity can render them in fewer draw calls. Unity provides two built-in draw call batching methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/draw-call-batching/static-batching"},"Static batching"),": For ",(0,i.kt)("a",{parentName:"li",href:"/docs/game-objects/static-objects"},"static")," GameObjects, Unity combines them and renders them together."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/draw-call-batching/dynamic-batching"},"Dynamic batching"),": For small enough meshes, this transforms their vertices on the CPU, groups similar vertices together, and renders them in one draw call.")),(0,i.kt)("p",null,"Unity\u2019s built-in draw call batching has several advantages over manually merging meshes; most notably, Unity can still cull meshes individually. However, it also has some downsides; static batching incurs memory and storage overhead, and dynamic batching incurs some CPU overhead."),(0,i.kt)("h2",{id:"requirements-and-compatibility"},"Requirements and compatibility"),(0,i.kt)("p",null,"This section includes information about the render pipeline compatibility of Unity\u2019s built-in draw call batching methods."),(0,i.kt)("h3",{id:"render-pipeline-compatibility"},"Render pipeline compatibility"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u529f\u80fd")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u5185\u7f6e\u6e32\u67d3\u7ba1\u7ebf")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u901a\u7528\u6e32\u67d3\u7ba1\u7ebf (URP)")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"\u9ad8\u6e05\u6e32\u67d3\u7ba1\u7ebf (HDRP)")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Custom Scriptable Render Pipeline (SRP)")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Static Batching")),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f"),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f"),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f"),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Dynamic Batching")),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f"),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5426"),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f")))),(0,i.kt)("h2",{id:"using-draw-call-batching"},"Using draw call batching"),(0,i.kt)("p",null,"The following usage information is relevant for both static and dynamic batching. For information specific to each draw call batching method, such as how to enable and use each method, see ",(0,i.kt)("a",{parentName:"p",href:"/docs/draw-call-batching/static-batching"},"Static batching")," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/draw-call-batching/dynamic-batching"},"Dynamic batching"),"."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/comp-mesh-group/class-mesh-renderer"},"Mesh Renderers"),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/visual-effects-lines-trails-billboards/class-trail-renderer"},"Trail Renderers"),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/visual-effects-lines-trails-billboards/class-line-renderer"},"Line Renderers"),", ",(0,i.kt)("a",{parentName:"p",href:"/docs/part-sys-reference/class-particle-system"},"Particle Systems"),", and ",(0,i.kt)("a",{parentName:"p",href:"/docs/sprites/class-sprite-renderer"},"Sprite Renderers")," are supported for draw call batching. Other types of rendering components, including Skinned Mesh Renderers Cloth, are not supported. Unity only batches Renderers with other Renderers of the same type; for example, Mesh Renderers with Mesh Renderers."),(0,i.kt)("p",null,"Unity batches draw calls of GameObjects that use the same material. This means to get the best results from draw call batching, share materials among as many GameObjects as possible. If you have two material assets that are identical apart from their textures, you can combine the textures into a single, larger texture. This process is called texture atlasing. For more information, see the ",(0,i.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Texture_atlas"},"Wikipedia article")," on texture atlasing. When textures are in the same atlas, you can use a single material asset instead."),(0,i.kt)("p",null,"In the Built-in Render Pipeline, you can use a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/MaterialPropertyBlock.html"},"MaterialPropertyBlock")," to change material properties without breaking draw call batching. The CPU still needs to make some render-state changes, but using a ",(0,i.kt)("inlineCode",{parentName:"p"},"MaterialPropertyBlock")," is faster than using multiple materials. If your project uses a Scriptable Render Pipeline, don\u2019t use a ",(0,i.kt)("inlineCode",{parentName:"p"},"MaterialPropertyBlock")," because they remove SRP Batcher compatibility for the material."),(0,i.kt)("p",null,"Transparent shaders often require Unity to render meshes in back-to-front order. To batch transparent meshes, Unity first orders them from back to front and then tries to batch them. Since Unity must render the meshes back-to-front, it often can\u2019t batch as many transparent meshes as opaque meshes."),(0,i.kt)("p",null,"Unity can\u2019t apply dynamic batching to GameObjects that contain mirroring in their Transform component. For example, if one GameObject has a scale of  ",(0,i.kt)("strong",{parentName:"p"},"1"),"  and another GameObject has a scale of  ",(0,i.kt)("strong",{parentName:"p"},"\u20131")," , Unity can\u2019t batch them together."),(0,i.kt)("p",null,"If you are not able to use draw call batching, manually combining meshes that are close to each other can be a good alternative. For more information on combining meshes, see ",(0,i.kt)("a",{parentName:"p",href:"/docs/optimizing-draw-calls/combining-meshes"},"Combining meshes"),"."),(0,i.kt)("p",null," ",(0,i.kt)("strong",{parentName:"p"},"Warning")," : When you access shared material properties from a C# script, make sure to use ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/Renderer-sharedMaterial.html"},"Renderer.sharedMaterial")," and not ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/cn/2022.1/Manual/Renderer-material.html"},"Renderer.material"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Renderer.material")," creates a copy of the material and assigns the copy back to the Renderer. This stops Unity from batching the draw calls for that Renderer."),(0,i.kt)("hr",null),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2017\u201310\u201326 \u9875\u9762\u5df2\u4fee\u8ba2"),(0,i.kt)("li",{parentName:"ul"},"\u5728 2017.2 \u7248\u4e2d\u6dfb\u52a0\u4e86\u6709\u5173\u52a8\u6001\u6279\u5904\u7406\u4e0e\u56fe\u5f62\u4f5c\u4e1a\u4e0d\u517c\u5bb9\u7684\u5907\u6ce8")))}d.isMDXComponent=!0}}]);